"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.source = void 0;
const source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/server/injected/injectedScript.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"./src/server/common/cssParser.ts\":\n/*!****************************************!*\\\n  !*** ./src/server/common/cssParser.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseCSS = parseCSS;\nexports.serializeSelector = serializeSelector;\n\nvar css = _interopRequireWildcard(__webpack_require__(/*! ./cssTokenizer */ \"./src/server/common/cssTokenizer.js\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction parseCSS(selector, customNames) {\n  let tokens;\n\n  try {\n    tokens = css.tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof css.EOFToken)) tokens.push(new css.EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing selector \"${selector}\"`;\n    const index = (e.stack || '').indexOf(e.message);\n    if (index !== -1) e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n\n  const unsupportedToken = tokens.find(token => {\n    return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.\n    // For example :xpath{ (//div/bar[@attr=\"foo\"])[2]/baz }\n    // Or this way :xpath( {complex-xpath-goes-here(\"hello\")} )\n    token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken || // TODO: Consider treating these as strings?\n    token instanceof css.URLToken || token instanceof css.PercentageToken;\n  });\n  if (unsupportedToken) throw new Error(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing selector \"${selector}\"`);\n  let pos = 0;\n  const names = new Set();\n\n  function unexpected() {\n    return new Error(`Unexpected token \"${tokens[pos].toSource()}\" while parsing selector \"${selector}\"`);\n  }\n\n  function skipWhitespace() {\n    while (tokens[pos] instanceof css.WhitespaceToken) pos++;\n  }\n\n  function isIdent(p = pos) {\n    return tokens[p] instanceof css.IdentToken;\n  }\n\n  function isString(p = pos) {\n    return tokens[p] instanceof css.StringToken;\n  }\n\n  function isNumber(p = pos) {\n    return tokens[p] instanceof css.NumberToken;\n  }\n\n  function isComma(p = pos) {\n    return tokens[p] instanceof css.CommaToken;\n  }\n\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof css.CloseParenToken;\n  }\n\n  function isStar(p = pos) {\n    return tokens[p] instanceof css.DelimToken && tokens[p].value === '*';\n  }\n\n  function isEOF(p = pos) {\n    return tokens[p] instanceof css.EOFToken;\n  }\n\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof css.DelimToken && ['>', '+', '~'].includes(tokens[p].value);\n  }\n\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;\n  }\n\n  function consumeFunctionArguments() {\n    const result = [consumeArgument()];\n\n    while (true) {\n      skipWhitespace();\n      if (!isComma()) break;\n      pos++;\n      result.push(consumeArgument());\n    }\n\n    return result;\n  }\n\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber()) return tokens[pos++].value;\n    if (isString()) return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n\n  function consumeComplexSelector() {\n    skipWhitespace();\n    const result = {\n      simples: [{\n        selector: consumeSimpleSelector(),\n        combinator: ''\n      }]\n    };\n\n    while (true) {\n      skipWhitespace();\n\n      if (isClauseCombinator()) {\n        result.simples[result.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n\n      result.simples.push({\n        combinator: '',\n        selector: consumeSimpleSelector()\n      });\n    }\n\n    return result;\n  }\n\n  function consumeSimpleSelector() {\n    let rawCSSString = '';\n    const functions = [];\n\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === '.') {\n        pos++;\n        if (isIdent()) rawCSSString += '.' + tokens[pos++].toSource();else throw unexpected();\n      } else if (tokens[pos] instanceof css.ColonToken) {\n        pos++;\n\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ':' + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({\n              name,\n              args: []\n            });\n            names.add(name);\n          }\n        } else if (tokens[pos] instanceof css.FunctionToken) {\n          const name = tokens[pos++].value.toLowerCase();\n\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({\n              name,\n              args: consumeFunctionArguments()\n            });\n            names.add(name);\n          }\n\n          skipWhitespace();\n          if (!isCloseParen()) throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof css.OpenSquareToken) {\n        rawCSSString += '[';\n        pos++;\n\n        while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF()) rawCSSString += tokens[pos++].toSource();\n\n        if (!(tokens[pos] instanceof css.CloseSquareToken)) throw unexpected();\n        rawCSSString += ']';\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n\n    if (!rawCSSString && !functions.length) throw unexpected();\n    return {\n      css: rawCSSString || undefined,\n      functions\n    };\n  }\n\n  function consumeBuiltinFunctionArguments() {\n    let s = '';\n\n    while (!isCloseParen() && !isEOF()) s += tokens[pos++].toSource();\n\n    return s;\n  }\n\n  const result = consumeFunctionArguments();\n  if (!isEOF()) throw new Error(`Error while parsing selector \"${selector}\"`);\n  if (result.some(arg => typeof arg !== 'object' || !('simples' in arg))) throw new Error(`Error while parsing selector \"${selector}\"`);\n  return {\n    selector: result,\n    names: Array.from(names)\n  };\n}\n\nfunction serializeSelector(args) {\n  return args.map(arg => {\n    if (typeof arg === 'string') return `\"${arg}\"`;\n    if (typeof arg === 'number') return String(arg);\n    return arg.simples.map(({\n      selector,\n      combinator\n    }) => {\n      let s = selector.css || '';\n      s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');\n      if (combinator) s += ' ' + combinator;\n      return s;\n    }).join(' ');\n  }).join(', ');\n}\n\n/***/ }),\n\n/***/ \"./src/server/common/cssTokenizer.js\":\n/*!*******************************************!*\\\n  !*** ./src/server/common/cssTokenizer.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n/*\n * Original at https://github.com/tabatkins/parse-css\n * licensed under http://creativecommons.org/publicdomain/zero/1.0/\n *\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Changes from https://github.com/tabatkins/parse-css\n//   - Tabs are replaced with two spaces.\n//   - Everything not related to tokenizing - below the first exports block - is removed.\n// @ts-nocheck\n(function (root, factory) {\n  // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(void 0, function (exports) {\n  var between = function (num, first, last) {\n    return num >= first && num <= last;\n  };\n\n  function digit(code) {\n    return between(code, 0x30, 0x39);\n  }\n\n  function hexdigit(code) {\n    return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66);\n  }\n\n  function uppercaseletter(code) {\n    return between(code, 0x41, 0x5a);\n  }\n\n  function lowercaseletter(code) {\n    return between(code, 0x61, 0x7a);\n  }\n\n  function letter(code) {\n    return uppercaseletter(code) || lowercaseletter(code);\n  }\n\n  function nonascii(code) {\n    return code >= 0x80;\n  }\n\n  function namestartchar(code) {\n    return letter(code) || nonascii(code) || code == 0x5f;\n  }\n\n  function namechar(code) {\n    return namestartchar(code) || digit(code) || code == 0x2d;\n  }\n\n  function nonprintable(code) {\n    return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f;\n  }\n\n  function newline(code) {\n    return code == 0xa;\n  }\n\n  function whitespace(code) {\n    return newline(code) || code == 9 || code == 0x20;\n  }\n\n  function badescape(code) {\n    return newline(code) || isNaN(code);\n  }\n\n  var maximumallowedcodepoint = 0x10ffff;\n\n  var InvalidCharacterError = function (message) {\n    this.message = message;\n  };\n\n  InvalidCharacterError.prototype = new Error();\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  function preprocess(str) {\n    // Turn a string into an array of code points,\n    // following the preprocessing cleanup rules.\n    var codepoints = [];\n\n    for (var i = 0; i < str.length; i++) {\n      var code = str.charCodeAt(i);\n\n      if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {\n        code = 0xa;\n        i++;\n      }\n\n      if (code == 0xd || code == 0xc) code = 0xa;\n      if (code == 0x0) code = 0xfffd;\n\n      if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {\n        // Decode a surrogate pair into an astral codepoint.\n        var lead = code - 0xd800;\n        var trail = str.charCodeAt(i + 1) - 0xdc00;\n        code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n        i++;\n      }\n\n      codepoints.push(code);\n    }\n\n    return codepoints;\n  }\n\n  function stringFromCode(code) {\n    if (code <= 0xffff) return String.fromCharCode(code); // Otherwise, encode astral char as surrogate pair.\n\n    code -= Math.pow(2, 16);\n    var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;\n    var trail = code % Math.pow(2, 10) + 0xdc00;\n    return String.fromCharCode(lead) + String.fromCharCode(trail);\n  }\n\n  function tokenize(str) {\n    str = preprocess(str);\n    var i = -1;\n    var tokens = [];\n    var code; // Line number information.\n\n    var line = 0;\n    var column = 0; // The only use of lastLineLength is in reconsume().\n\n    var lastLineLength = 0;\n\n    var incrLineno = function () {\n      line += 1;\n      lastLineLength = column;\n      column = 0;\n    };\n\n    var locStart = {\n      line: line,\n      column: column\n    };\n\n    var codepoint = function (i) {\n      if (i >= str.length) {\n        return -1;\n      }\n\n      return str[i];\n    };\n\n    var next = function (num) {\n      if (num === undefined) num = 1;\n      if (num > 3) throw \"Spec Error: no more than three codepoints of lookahead.\";\n      return codepoint(i + num);\n    };\n\n    var consume = function (num) {\n      if (num === undefined) num = 1;\n      i += num;\n      code = codepoint(i);\n      if (newline(code)) incrLineno();else column += num; //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n\n      return true;\n    };\n\n    var reconsume = function () {\n      i -= 1;\n\n      if (newline(code)) {\n        line -= 1;\n        column = lastLineLength;\n      } else {\n        column -= 1;\n      }\n\n      locStart.line = line;\n      locStart.column = column;\n      return true;\n    };\n\n    var eof = function (codepoint) {\n      if (codepoint === undefined) codepoint = code;\n      return codepoint == -1;\n    };\n\n    var donothing = function () {};\n\n    var parseerror = function () {\n      console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");\n      return true;\n    };\n\n    var consumeAToken = function () {\n      consumeComments();\n      consume();\n\n      if (whitespace(code)) {\n        while (whitespace(next())) consume();\n\n        return new WhitespaceToken();\n      } else if (code == 0x22) return consumeAStringToken();else if (code == 0x23) {\n        if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n          var token = new HashToken();\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = \"id\";\n          token.value = consumeAName();\n          return token;\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x24) {\n        if (next() == 0x3d) {\n          consume();\n          return new SuffixMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x27) return consumeAStringToken();else if (code == 0x28) return new OpenParenToken();else if (code == 0x29) return new CloseParenToken();else if (code == 0x2a) {\n        if (next() == 0x3d) {\n          consume();\n          return new SubstringMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x2b) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x2c) return new CommaToken();else if (code == 0x2d) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else if (next(1) == 0x2d && next(2) == 0x3e) {\n          consume(2);\n          return new CDCToken();\n        } else if (startsWithAnIdentifier()) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x2e) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x3a) return new ColonToken();else if (code == 0x3b) return new SemicolonToken();else if (code == 0x3c) {\n        if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n          consume(3);\n          return new CDOToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x40) {\n        if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n          return new AtKeywordToken(consumeAName());\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x5b) return new OpenSquareToken();else if (code == 0x5c) {\n        if (startsWithAValidEscape()) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else {\n          parseerror();\n          return new DelimToken(code);\n        }\n      } else if (code == 0x5d) return new CloseSquareToken();else if (code == 0x5e) {\n        if (next() == 0x3d) {\n          consume();\n          return new PrefixMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x7b) return new OpenCurlyToken();else if (code == 0x7c) {\n        if (next() == 0x3d) {\n          consume();\n          return new DashMatchToken();\n        } else if (next() == 0x7c) {\n          consume();\n          return new ColumnToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x7d) return new CloseCurlyToken();else if (code == 0x7e) {\n        if (next() == 0x3d) {\n          consume();\n          return new IncludeMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (digit(code)) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (namestartchar(code)) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else if (eof()) return new EOFToken();else return new DelimToken(code);\n    };\n\n    var consumeComments = function () {\n      while (next(1) == 0x2f && next(2) == 0x2a) {\n        consume(2);\n\n        while (true) {\n          consume();\n\n          if (code == 0x2a && next() == 0x2f) {\n            consume();\n            break;\n          } else if (eof()) {\n            parseerror();\n            return;\n          }\n        }\n      }\n    };\n\n    var consumeANumericToken = function () {\n      var num = consumeANumber();\n\n      if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n        var token = new DimensionToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        token.type = num.type;\n        token.unit = consumeAName();\n        return token;\n      } else if (next() == 0x25) {\n        consume();\n        var token = new PercentageToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        return token;\n      } else {\n        var token = new NumberToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        token.type = num.type;\n        return token;\n      }\n    };\n\n    var consumeAnIdentlikeToken = function () {\n      var str = consumeAName();\n\n      if (str.toLowerCase() == \"url\" && next() == 0x28) {\n        consume();\n\n        while (whitespace(next(1)) && whitespace(next(2))) consume();\n\n        if (next() == 0x22 || next() == 0x27) {\n          return new FunctionToken(str);\n        } else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n          return new FunctionToken(str);\n        } else {\n          return consumeAURLToken();\n        }\n      } else if (next() == 0x28) {\n        consume();\n        return new FunctionToken(str);\n      } else {\n        return new IdentToken(str);\n      }\n    };\n\n    var consumeAStringToken = function (endingCodePoint) {\n      if (endingCodePoint === undefined) endingCodePoint = code;\n      var string = \"\";\n\n      while (consume()) {\n        if (code == endingCodePoint || eof()) {\n          return new StringToken(string);\n        } else if (newline(code)) {\n          parseerror();\n          reconsume();\n          return new BadStringToken();\n        } else if (code == 0x5c) {\n          if (eof(next())) {\n            donothing();\n          } else if (newline(next())) {\n            consume();\n          } else {\n            string += stringFromCode(consumeEscape());\n          }\n        } else {\n          string += stringFromCode(code);\n        }\n      }\n    };\n\n    var consumeAURLToken = function () {\n      var token = new URLToken(\"\");\n\n      while (whitespace(next())) consume();\n\n      if (eof(next())) return token;\n\n      while (consume()) {\n        if (code == 0x29 || eof()) {\n          return token;\n        } else if (whitespace(code)) {\n          while (whitespace(next())) consume();\n\n          if (next() == 0x29 || eof(next())) {\n            consume();\n            return token;\n          } else {\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken();\n          }\n        } else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        } else if (code == 0x5c) {\n          if (startsWithAValidEscape()) {\n            token.value += stringFromCode(consumeEscape());\n          } else {\n            parseerror();\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken();\n          }\n        } else {\n          token.value += stringFromCode(code);\n        }\n      }\n    };\n\n    var consumeEscape = function () {\n      // Assume the the current character is the \\\n      // and the next code point is not a newline.\n      consume();\n\n      if (hexdigit(code)) {\n        // Consume 1-6 hex digits\n        var digits = [code];\n\n        for (var total = 0; total < 5; total++) {\n          if (hexdigit(next())) {\n            consume();\n            digits.push(code);\n          } else {\n            break;\n          }\n        }\n\n        if (whitespace(next())) consume();\n        var value = parseInt(digits.map(function (x) {\n          return String.fromCharCode(x);\n        }).join(''), 16);\n        if (value > maximumallowedcodepoint) value = 0xfffd;\n        return value;\n      } else if (eof()) {\n        return 0xfffd;\n      } else {\n        return code;\n      }\n    };\n\n    var areAValidEscape = function (c1, c2) {\n      if (c1 != 0x5c) return false;\n      if (newline(c2)) return false;\n      return true;\n    };\n\n    var startsWithAValidEscape = function () {\n      return areAValidEscape(code, next());\n    };\n\n    var wouldStartAnIdentifier = function (c1, c2, c3) {\n      if (c1 == 0x2d) {\n        return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n      } else if (namestartchar(c1)) {\n        return true;\n      } else if (c1 == 0x5c) {\n        return areAValidEscape(c1, c2);\n      } else {\n        return false;\n      }\n    };\n\n    var startsWithAnIdentifier = function () {\n      return wouldStartAnIdentifier(code, next(1), next(2));\n    };\n\n    var wouldStartANumber = function (c1, c2, c3) {\n      if (c1 == 0x2b || c1 == 0x2d) {\n        if (digit(c2)) return true;\n        if (c2 == 0x2e && digit(c3)) return true;\n        return false;\n      } else if (c1 == 0x2e) {\n        if (digit(c2)) return true;\n        return false;\n      } else if (digit(c1)) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    var startsWithANumber = function () {\n      return wouldStartANumber(code, next(1), next(2));\n    };\n\n    var consumeAName = function () {\n      var result = \"\";\n\n      while (consume()) {\n        if (namechar(code)) {\n          result += stringFromCode(code);\n        } else if (startsWithAValidEscape()) {\n          result += stringFromCode(consumeEscape());\n        } else {\n          reconsume();\n          return result;\n        }\n      }\n    };\n\n    var consumeANumber = function () {\n      var repr = [];\n      var type = \"integer\";\n\n      if (next() == 0x2b || next() == 0x2d) {\n        consume();\n        repr += stringFromCode(code);\n      }\n\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n\n      if (next(1) == 0x2e && digit(next(2))) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = \"number\";\n\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      }\n\n      var c1 = next(1),\n          c2 = next(2),\n          c3 = next(3);\n\n      if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = \"number\";\n\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      } else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = \"number\";\n\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      }\n\n      var value = convertAStringToANumber(repr);\n      return {\n        type: type,\n        value: value,\n        repr: repr\n      };\n    };\n\n    var convertAStringToANumber = function (string) {\n      // CSS's number rules are identical to JS, afaik.\n      return +string;\n    };\n\n    var consumeTheRemnantsOfABadURL = function () {\n      while (consume()) {\n        if (code == 0x29 || eof()) {\n          return;\n        } else if (startsWithAValidEscape()) {\n          consumeEscape();\n          donothing();\n        } else {\n          donothing();\n        }\n      }\n    };\n\n    var iterationCount = 0;\n\n    while (!eof(next())) {\n      tokens.push(consumeAToken());\n      iterationCount++;\n      if (iterationCount > str.length * 2) return \"I'm infinite-looping!\";\n    }\n\n    return tokens;\n  }\n\n  function CSSParserToken() {\n    throw \"Abstract Base Class\";\n  }\n\n  CSSParserToken.prototype.toJSON = function () {\n    return {\n      token: this.tokenType\n    };\n  };\n\n  CSSParserToken.prototype.toString = function () {\n    return this.tokenType;\n  };\n\n  CSSParserToken.prototype.toSource = function () {\n    return '' + this;\n  };\n\n  function BadStringToken() {\n    return this;\n  }\n\n  BadStringToken.prototype = Object.create(CSSParserToken.prototype);\n  BadStringToken.prototype.tokenType = \"BADSTRING\";\n\n  function BadURLToken() {\n    return this;\n  }\n\n  BadURLToken.prototype = Object.create(CSSParserToken.prototype);\n  BadURLToken.prototype.tokenType = \"BADURL\";\n\n  function WhitespaceToken() {\n    return this;\n  }\n\n  WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);\n  WhitespaceToken.prototype.tokenType = \"WHITESPACE\";\n\n  WhitespaceToken.prototype.toString = function () {\n    return \"WS\";\n  };\n\n  WhitespaceToken.prototype.toSource = function () {\n    return \" \";\n  };\n\n  function CDOToken() {\n    return this;\n  }\n\n  CDOToken.prototype = Object.create(CSSParserToken.prototype);\n  CDOToken.prototype.tokenType = \"CDO\";\n\n  CDOToken.prototype.toSource = function () {\n    return \"<!--\";\n  };\n\n  function CDCToken() {\n    return this;\n  }\n\n  CDCToken.prototype = Object.create(CSSParserToken.prototype);\n  CDCToken.prototype.tokenType = \"CDC\";\n\n  CDCToken.prototype.toSource = function () {\n    return \"-->\";\n  };\n\n  function ColonToken() {\n    return this;\n  }\n\n  ColonToken.prototype = Object.create(CSSParserToken.prototype);\n  ColonToken.prototype.tokenType = \":\";\n\n  function SemicolonToken() {\n    return this;\n  }\n\n  SemicolonToken.prototype = Object.create(CSSParserToken.prototype);\n  SemicolonToken.prototype.tokenType = \";\";\n\n  function CommaToken() {\n    return this;\n  }\n\n  CommaToken.prototype = Object.create(CSSParserToken.prototype);\n  CommaToken.prototype.tokenType = \",\";\n\n  function GroupingToken() {\n    throw \"Abstract Base Class\";\n  }\n\n  GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n\n  function OpenCurlyToken() {\n    this.value = \"{\";\n    this.mirror = \"}\";\n    return this;\n  }\n\n  OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);\n  OpenCurlyToken.prototype.tokenType = \"{\";\n\n  function CloseCurlyToken() {\n    this.value = \"}\";\n    this.mirror = \"{\";\n    return this;\n  }\n\n  CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);\n  CloseCurlyToken.prototype.tokenType = \"}\";\n\n  function OpenSquareToken() {\n    this.value = \"[\";\n    this.mirror = \"]\";\n    return this;\n  }\n\n  OpenSquareToken.prototype = Object.create(GroupingToken.prototype);\n  OpenSquareToken.prototype.tokenType = \"[\";\n\n  function CloseSquareToken() {\n    this.value = \"]\";\n    this.mirror = \"[\";\n    return this;\n  }\n\n  CloseSquareToken.prototype = Object.create(GroupingToken.prototype);\n  CloseSquareToken.prototype.tokenType = \"]\";\n\n  function OpenParenToken() {\n    this.value = \"(\";\n    this.mirror = \")\";\n    return this;\n  }\n\n  OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n  OpenParenToken.prototype.tokenType = \"(\";\n\n  function CloseParenToken() {\n    this.value = \")\";\n    this.mirror = \"(\";\n    return this;\n  }\n\n  CloseParenToken.prototype = Object.create(GroupingToken.prototype);\n  CloseParenToken.prototype.tokenType = \")\";\n\n  function IncludeMatchToken() {\n    return this;\n  }\n\n  IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  IncludeMatchToken.prototype.tokenType = \"~=\";\n\n  function DashMatchToken() {\n    return this;\n  }\n\n  DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  DashMatchToken.prototype.tokenType = \"|=\";\n\n  function PrefixMatchToken() {\n    return this;\n  }\n\n  PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  PrefixMatchToken.prototype.tokenType = \"^=\";\n\n  function SuffixMatchToken() {\n    return this;\n  }\n\n  SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  SuffixMatchToken.prototype.tokenType = \"$=\";\n\n  function SubstringMatchToken() {\n    return this;\n  }\n\n  SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  SubstringMatchToken.prototype.tokenType = \"*=\";\n\n  function ColumnToken() {\n    return this;\n  }\n\n  ColumnToken.prototype = Object.create(CSSParserToken.prototype);\n  ColumnToken.prototype.tokenType = \"||\";\n\n  function EOFToken() {\n    return this;\n  }\n\n  EOFToken.prototype = Object.create(CSSParserToken.prototype);\n  EOFToken.prototype.tokenType = \"EOF\";\n\n  EOFToken.prototype.toSource = function () {\n    return \"\";\n  };\n\n  function DelimToken(code) {\n    this.value = stringFromCode(code);\n    return this;\n  }\n\n  DelimToken.prototype = Object.create(CSSParserToken.prototype);\n  DelimToken.prototype.tokenType = \"DELIM\";\n\n  DelimToken.prototype.toString = function () {\n    return \"DELIM(\" + this.value + \")\";\n  };\n\n  DelimToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  };\n\n  DelimToken.prototype.toSource = function () {\n    if (this.value == \"\\\\\") return \"\\\\\\n\";else return this.value;\n  };\n\n  function StringValuedToken() {\n    throw \"Abstract Base Class\";\n  }\n\n  StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n\n  StringValuedToken.prototype.ASCIIMatch = function (str) {\n    return this.value.toLowerCase() == str.toLowerCase();\n  };\n\n  StringValuedToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  };\n\n  function IdentToken(val) {\n    this.value = val;\n  }\n\n  IdentToken.prototype = Object.create(StringValuedToken.prototype);\n  IdentToken.prototype.tokenType = \"IDENT\";\n\n  IdentToken.prototype.toString = function () {\n    return \"IDENT(\" + this.value + \")\";\n  };\n\n  IdentToken.prototype.toSource = function () {\n    return escapeIdent(this.value);\n  };\n\n  function FunctionToken(val) {\n    this.value = val;\n    this.mirror = \")\";\n  }\n\n  FunctionToken.prototype = Object.create(StringValuedToken.prototype);\n  FunctionToken.prototype.tokenType = \"FUNCTION\";\n\n  FunctionToken.prototype.toString = function () {\n    return \"FUNCTION(\" + this.value + \")\";\n  };\n\n  FunctionToken.prototype.toSource = function () {\n    return escapeIdent(this.value) + \"(\";\n  };\n\n  function AtKeywordToken(val) {\n    this.value = val;\n  }\n\n  AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);\n  AtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\n\n  AtKeywordToken.prototype.toString = function () {\n    return \"AT(\" + this.value + \")\";\n  };\n\n  AtKeywordToken.prototype.toSource = function () {\n    return \"@\" + escapeIdent(this.value);\n  };\n\n  function HashToken(val) {\n    this.value = val;\n    this.type = \"unrestricted\";\n  }\n\n  HashToken.prototype = Object.create(StringValuedToken.prototype);\n  HashToken.prototype.tokenType = \"HASH\";\n\n  HashToken.prototype.toString = function () {\n    return \"HASH(\" + this.value + \")\";\n  };\n\n  HashToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  };\n\n  HashToken.prototype.toSource = function () {\n    if (this.type == \"id\") {\n      return \"#\" + escapeIdent(this.value);\n    } else {\n      return \"#\" + escapeHash(this.value);\n    }\n  };\n\n  function StringToken(val) {\n    this.value = val;\n  }\n\n  StringToken.prototype = Object.create(StringValuedToken.prototype);\n  StringToken.prototype.tokenType = \"STRING\";\n\n  StringToken.prototype.toString = function () {\n    return '\"' + escapeString(this.value) + '\"';\n  };\n\n  function URLToken(val) {\n    this.value = val;\n  }\n\n  URLToken.prototype = Object.create(StringValuedToken.prototype);\n  URLToken.prototype.tokenType = \"URL\";\n\n  URLToken.prototype.toString = function () {\n    return \"URL(\" + this.value + \")\";\n  };\n\n  URLToken.prototype.toSource = function () {\n    return 'url(\"' + escapeString(this.value) + '\")';\n  };\n\n  function NumberToken() {\n    this.value = null;\n    this.type = \"integer\";\n    this.repr = \"\";\n  }\n\n  NumberToken.prototype = Object.create(CSSParserToken.prototype);\n  NumberToken.prototype.tokenType = \"NUMBER\";\n\n  NumberToken.prototype.toString = function () {\n    if (this.type == \"integer\") return \"INT(\" + this.value + \")\";\n    return \"NUMBER(\" + this.value + \")\";\n  };\n\n  NumberToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  };\n\n  NumberToken.prototype.toSource = function () {\n    return this.repr;\n  };\n\n  function PercentageToken() {\n    this.value = null;\n    this.repr = \"\";\n  }\n\n  PercentageToken.prototype = Object.create(CSSParserToken.prototype);\n  PercentageToken.prototype.tokenType = \"PERCENTAGE\";\n\n  PercentageToken.prototype.toString = function () {\n    return \"PERCENTAGE(\" + this.value + \")\";\n  };\n\n  PercentageToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  };\n\n  PercentageToken.prototype.toSource = function () {\n    return this.repr + \"%\";\n  };\n\n  function DimensionToken() {\n    this.value = null;\n    this.type = \"integer\";\n    this.repr = \"\";\n    this.unit = \"\";\n  }\n\n  DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n  DimensionToken.prototype.tokenType = \"DIMENSION\";\n\n  DimensionToken.prototype.toString = function () {\n    return \"DIM(\" + this.value + \",\" + this.unit + \")\";\n  };\n\n  DimensionToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  };\n\n  DimensionToken.prototype.toSource = function () {\n    var source = this.repr;\n    var unit = escapeIdent(this.unit);\n\n    if (unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n      // Unit is ambiguous with scinot\n      // Remove the leading \"e\", replace with escape.\n      unit = \"\\\\65 \" + unit.slice(1, unit.length);\n    }\n\n    return source + unit;\n  };\n\n  function escapeIdent(string) {\n    string = '' + string;\n    var result = '';\n    var firstcode = string.charCodeAt(0);\n\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i);\n\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n      }\n\n      if (between(code, 0x1, 0x1f) || code == 0x7f || i == 0 && between(code, 0x30, 0x39) || i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d) {\n        result += '\\\\' + code.toString(16) + ' ';\n      } else if (code >= 0x80 || code == 0x2d || code == 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) {\n        result += string[i];\n      } else {\n        result += '\\\\' + string[i];\n      }\n    }\n\n    return result;\n  }\n\n  function escapeHash(string) {\n    // Escapes the contents of \"unrestricted\"-type hash tokens.\n    // Won't preserve the ID-ness of \"id\"-type hash tokens;\n    // use escapeIdent() for that.\n    string = '' + string;\n    var result = '';\n    var firstcode = string.charCodeAt(0);\n\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i);\n\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n      }\n\n      if (code >= 0x80 || code == 0x2d || code == 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) {\n        result += string[i];\n      } else {\n        result += '\\\\' + code.toString(16) + ' ';\n      }\n    }\n\n    return result;\n  }\n\n  function escapeString(string) {\n    string = '' + string;\n    var result = '';\n\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i);\n\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n      }\n\n      if (between(code, 0x1, 0x1f) || code == 0x7f) {\n        result += '\\\\' + code.toString(16) + ' ';\n      } else if (code == 0x22 || code == 0x5c) {\n        result += '\\\\' + string[i];\n      } else {\n        result += string[i];\n      }\n    }\n\n    return result;\n  } // Exportation.\n\n\n  exports.tokenize = tokenize;\n  exports.IdentToken = IdentToken;\n  exports.FunctionToken = FunctionToken;\n  exports.AtKeywordToken = AtKeywordToken;\n  exports.HashToken = HashToken;\n  exports.StringToken = StringToken;\n  exports.BadStringToken = BadStringToken;\n  exports.URLToken = URLToken;\n  exports.BadURLToken = BadURLToken;\n  exports.DelimToken = DelimToken;\n  exports.NumberToken = NumberToken;\n  exports.PercentageToken = PercentageToken;\n  exports.DimensionToken = DimensionToken;\n  exports.IncludeMatchToken = IncludeMatchToken;\n  exports.DashMatchToken = DashMatchToken;\n  exports.PrefixMatchToken = PrefixMatchToken;\n  exports.SuffixMatchToken = SuffixMatchToken;\n  exports.SubstringMatchToken = SubstringMatchToken;\n  exports.ColumnToken = ColumnToken;\n  exports.WhitespaceToken = WhitespaceToken;\n  exports.CDOToken = CDOToken;\n  exports.CDCToken = CDCToken;\n  exports.ColonToken = ColonToken;\n  exports.SemicolonToken = SemicolonToken;\n  exports.CommaToken = CommaToken;\n  exports.OpenParenToken = OpenParenToken;\n  exports.CloseParenToken = CloseParenToken;\n  exports.OpenSquareToken = OpenSquareToken;\n  exports.CloseSquareToken = CloseSquareToken;\n  exports.OpenCurlyToken = OpenCurlyToken;\n  exports.CloseCurlyToken = CloseCurlyToken;\n  exports.EOFToken = EOFToken;\n  exports.CSSParserToken = CSSParserToken;\n  exports.GroupingToken = GroupingToken;\n});\n\n/***/ }),\n\n/***/ \"./src/server/common/selectorParser.ts\":\n/*!*********************************************!*\\\n  !*** ./src/server/common/selectorParser.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseSelector = parseSelector;\nexports.customCSSNames = void 0;\n\nvar _cssParser = __webpack_require__(/*! ./cssParser */ \"./src/server/common/cssParser.ts\");\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);\nexports.customCSSNames = customCSSNames;\n\nfunction parseSelector(selector) {\n  const result = parseSelectorV1(selector);\n  result.parts = result.parts.map(part => {\n    if (Array.isArray(part)) return part;\n\n    if (part.name === 'css' || part.name === 'css:light') {\n      if (part.name === 'css:light') part.body = ':light(' + part.body + ')';\n      const parsedCSS = (0, _cssParser.parseCSS)(part.body, customCSSNames);\n      return parsedCSS.selector;\n    }\n\n    return part;\n  });\n  return {\n    parts: result.parts,\n    capture: result.capture\n  };\n}\n\nfunction parseSelectorV1(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = {\n    parts: []\n  };\n\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf('=');\n    let name;\n    let body;\n\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n      name = 'text';\n      body = part;\n    } else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n      name = 'text';\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {\n      // If selector starts with '//' or '//' prefixed with multiple opening\n      // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817\n      // If selector starts with '..', consider xpath as well.\n      name = 'xpath';\n      body = part;\n    } else {\n      name = 'css';\n      body = part;\n    }\n\n    let capture = false;\n\n    if (name[0] === '*') {\n      capture = true;\n      name = name.substring(1);\n    }\n\n    result.parts.push({\n      name,\n      body\n    });\n\n    if (capture) {\n      if (result.capture !== undefined) throw new Error(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n\n  if (!selector.includes('>>')) {\n    index = selector.length;\n    append();\n    return result;\n  }\n\n  while (index < selector.length) {\n    const c = selector[index];\n\n    if (c === '\\\\' && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = undefined;\n      index++;\n    } else if (!quote && (c === '\"' || c === '\\'' || c === '`')) {\n      quote = c;\n      index++;\n    } else if (!quote && c === '>' && selector[index + 1] === '>') {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n\n  append();\n  return result;\n}\n\n/***/ }),\n\n/***/ \"./src/server/injected/injectedScript.ts\":\n/*!***********************************************!*\\\n  !*** ./src/server/injected/injectedScript.ts ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.InjectedScript = void 0;\n\nvar _xpathSelectorEngine = __webpack_require__(/*! ./xpathSelectorEngine */ \"./src/server/injected/xpathSelectorEngine.ts\");\n\nvar _selectorParser = __webpack_require__(/*! ../common/selectorParser */ \"./src/server/common/selectorParser.ts\");\n\nvar _selectorEvaluator = __webpack_require__(/*! ./selectorEvaluator */ \"./src/server/injected/selectorEvaluator.ts\");\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass InjectedScript {\n  constructor(stableRafCount, replaceRafWithTimeout, customEngines) {\n    this._enginesV1 = void 0;\n    this._evaluator = void 0;\n    this._stableRafCount = void 0;\n    this._replaceRafWithTimeout = void 0;\n    this._enginesV1 = new Map();\n\n    this._enginesV1.set('xpath', _xpathSelectorEngine.XPathEngine);\n\n    this._enginesV1.set('xpath:light', _xpathSelectorEngine.XPathEngine);\n\n    this._enginesV1.set('text', this._createTextEngine(true));\n\n    this._enginesV1.set('text:light', this._createTextEngine(false));\n\n    this._enginesV1.set('id', this._createAttributeEngine('id', true));\n\n    this._enginesV1.set('id:light', this._createAttributeEngine('id', false));\n\n    this._enginesV1.set('data-testid', this._createAttributeEngine('data-testid', true));\n\n    this._enginesV1.set('data-testid:light', this._createAttributeEngine('data-testid', false));\n\n    this._enginesV1.set('data-test-id', this._createAttributeEngine('data-test-id', true));\n\n    this._enginesV1.set('data-test-id:light', this._createAttributeEngine('data-test-id', false));\n\n    this._enginesV1.set('data-test', this._createAttributeEngine('data-test', true));\n\n    this._enginesV1.set('data-test:light', this._createAttributeEngine('data-test', false));\n\n    for (const {\n      name,\n      engine\n    } of customEngines) this._enginesV1.set(name, engine); // No custom engines in V2 for now.\n\n\n    this._evaluator = new _selectorEvaluator.SelectorEvaluatorImpl(new Map());\n    this._stableRafCount = stableRafCount;\n    this._replaceRafWithTimeout = replaceRafWithTimeout;\n  }\n\n  parseSelector(selector) {\n    const result = (0, _selectorParser.parseSelector)(selector);\n\n    for (const part of result.parts) {\n      if (!Array.isArray(part) && !this._enginesV1.has(part.name)) throw new Error(`Unknown engine \"${part.name}\" while parsing selector ${selector}`);\n    }\n\n    return result;\n  }\n\n  querySelector(selector, root) {\n    if (!root['querySelector']) throw new Error('Node is not queryable.');\n\n    this._evaluator.begin();\n\n    try {\n      return this._querySelectorRecursively(root, selector, 0);\n    } finally {\n      this._evaluator.end();\n    }\n  }\n\n  _querySelectorRecursively(root, selector, index) {\n    const current = selector.parts[index];\n    if (index === selector.parts.length - 1) return this._queryEngine(current, root);\n\n    const all = this._queryEngineAll(current, root);\n\n    for (const next of all) {\n      const result = this._querySelectorRecursively(next, selector, index + 1);\n\n      if (result) return selector.capture === index ? next : result;\n    }\n  }\n\n  querySelectorAll(selector, root) {\n    if (!root['querySelectorAll']) throw new Error('Node is not queryable.');\n\n    this._evaluator.begin();\n\n    try {\n      const capture = selector.capture === undefined ? selector.parts.length - 1 : selector.capture; // Query all elements up to the capture.\n\n      const partsToQueryAll = selector.parts.slice(0, capture + 1); // Check they have a descendant matching everything after the capture.\n\n      const partsToCheckOne = selector.parts.slice(capture + 1);\n      let set = new Set([root]);\n\n      for (const part of partsToQueryAll) {\n        const newSet = new Set();\n\n        for (const prev of set) {\n          for (const next of this._queryEngineAll(part, prev)) {\n            if (newSet.has(next)) continue;\n            newSet.add(next);\n          }\n        }\n\n        set = newSet;\n      }\n\n      let result = [...set];\n\n      if (partsToCheckOne.length) {\n        const partial = {\n          parts: partsToCheckOne\n        };\n        result = result.filter(e => !!this._querySelectorRecursively(e, partial, 0));\n      }\n\n      return result;\n    } finally {\n      this._evaluator.end();\n    }\n  }\n\n  _queryEngine(part, root) {\n    if (Array.isArray(part)) return this._evaluator.query({\n      scope: root,\n      pierceShadow: true\n    }, part)[0];\n    return this._enginesV1.get(part.name).query(root, part.body);\n  }\n\n  _queryEngineAll(part, root) {\n    if (Array.isArray(part)) return this._evaluator.query({\n      scope: root,\n      pierceShadow: true\n    }, part);\n    return this._enginesV1.get(part.name).queryAll(root, part.body);\n  }\n\n  _createAttributeEngine(attribute, shadow) {\n    const toCSS = selector => {\n      const css = `[${attribute}=${JSON.stringify(selector)}]`;\n      return [{\n        simples: [{\n          selector: {\n            css,\n            functions: []\n          },\n          combinator: ''\n        }]\n      }];\n    };\n\n    return {\n      query: (root, selector) => {\n        return this._evaluator.query({\n          scope: root,\n          pierceShadow: shadow\n        }, toCSS(selector))[0];\n      },\n      queryAll: (root, selector) => {\n        return this._evaluator.query({\n          scope: root,\n          pierceShadow: shadow\n        }, toCSS(selector));\n      }\n    };\n  }\n\n  _createTextEngine(shadow) {\n    const queryList = (root, selector, single) => {\n      const {\n        matcher,\n        kind\n      } = createTextMatcher(selector);\n      const result = [];\n      let lastDidNotMatchSelf = null;\n\n      const checkElement = element => {\n        // TODO: replace contains() with something shadow-dom-aware?\n        if (kind === 'lax' && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element)) return false;\n        const matches = (0, _selectorEvaluator.elementMatchesText)(this._evaluator, element, matcher);\n        if (matches === 'none') lastDidNotMatchSelf = element;\n        if (matches === 'self' || matches === 'selfAndChildren' && kind === 'strict') result.push(element);\n        return single && result.length > 0;\n      };\n\n      if (root.nodeType === Node.ELEMENT_NODE && checkElement(root)) return result;\n\n      const elements = this._evaluator._queryCSS({\n        scope: root,\n        pierceShadow: shadow\n      }, '*');\n\n      for (const element of elements) {\n        if (checkElement(element)) return result;\n      }\n\n      return result;\n    };\n\n    return {\n      query: (root, selector) => {\n        return queryList(root, selector, true)[0];\n      },\n      queryAll: (root, selector) => {\n        return queryList(root, selector, false);\n      }\n    };\n  }\n\n  extend(source, params) {\n    const constrFunction = global.eval(`\n    (() => {\n      ${source}\n      return pwExport;\n    })()`);\n    return new constrFunction(this, params);\n  }\n\n  isVisible(element) {\n    return (0, _selectorEvaluator.isVisible)(element);\n  }\n\n  pollRaf(predicate) {\n    return this._runAbortableTask(progress => {\n      let fulfill;\n      let reject;\n      const result = new Promise((f, r) => {\n        fulfill = f;\n        reject = r;\n      });\n\n      const onRaf = () => {\n        if (progress.aborted) return;\n\n        try {\n          const continuePolling = Symbol('continuePolling');\n          const success = predicate(progress, continuePolling);\n          if (success !== continuePolling) fulfill(success);else requestAnimationFrame(onRaf);\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      onRaf();\n      return result;\n    });\n  }\n\n  pollInterval(pollInterval, predicate) {\n    return this._runAbortableTask(progress => {\n      let fulfill;\n      let reject;\n      const result = new Promise((f, r) => {\n        fulfill = f;\n        reject = r;\n      });\n\n      const onTimeout = () => {\n        if (progress.aborted) return;\n\n        try {\n          const continuePolling = Symbol('continuePolling');\n          const success = predicate(progress, continuePolling);\n          if (success !== continuePolling) fulfill(success);else setTimeout(onTimeout, pollInterval);\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      onTimeout();\n      return result;\n    });\n  }\n\n  _runAbortableTask(task) {\n    let unsentLogs = [];\n    let takeNextLogsCallback;\n    let taskFinished = false;\n\n    const logReady = () => {\n      if (!takeNextLogsCallback) return;\n      takeNextLogsCallback(unsentLogs);\n      unsentLogs = [];\n      takeNextLogsCallback = undefined;\n    };\n\n    const takeNextLogs = () => new Promise(fulfill => {\n      takeNextLogsCallback = fulfill;\n      if (unsentLogs.length || taskFinished) logReady();\n    });\n\n    let lastLog = '';\n    const progress = {\n      aborted: false,\n      log: message => {\n        lastLog = message;\n        unsentLogs.push(message);\n        logReady();\n      },\n      logRepeating: message => {\n        if (message !== lastLog) progress.log(message);\n      }\n    };\n\n    const run = () => {\n      const result = task(progress); // After the task has finished, there should be no more logs.\n      // Release any pending `takeNextLogs` call, and do not block any future ones.\n      // This prevents non-finished protocol evaluation calls and memory leaks.\n\n      result.finally(() => {\n        taskFinished = true;\n        logReady();\n      });\n      return result;\n    };\n\n    return {\n      takeNextLogs,\n      run,\n      cancel: () => {\n        progress.aborted = true;\n      },\n      takeLastLogs: () => unsentLogs\n    };\n  }\n\n  getElementBorderWidth(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView) return {\n      left: 0,\n      top: 0\n    };\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\n    return {\n      left: parseInt(style.borderLeftWidth || '', 10),\n      top: parseInt(style.borderTopWidth || '', 10)\n    };\n  }\n\n  retarget(node, behavior) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element) return null;\n    if (!element.matches('input, textarea, select')) element = element.closest('button, [role=button], [role=checkbox], [role=radio]') || element;\n\n    if (behavior === 'follow-label') {\n      if (!element.matches('input, textarea, button, select, [role=button], [role=checkbox], [role=radio]') && !element.isContentEditable) {\n        // Go up to the label that might be connected to the input/textarea.\n        element = element.closest('label') || element;\n      }\n\n      if (element.nodeName === 'LABEL') element = element.control || element;\n    }\n\n    return element;\n  }\n\n  waitForElementStatesAndPerformAction(node, states, force, callback) {\n    let lastRect;\n    let counter = 0;\n    let samePositionCounter = 0;\n    let lastTime = 0;\n\n    const predicate = (progress, continuePolling) => {\n      if (force) {\n        progress.log(`    forcing action`);\n        return callback(node, progress, continuePolling);\n      }\n\n      for (const state of states) {\n        if (state !== 'stable') {\n          const result = this.checkElementState(node, state);\n          if (typeof result !== 'boolean') return result;\n\n          if (!result) {\n            progress.logRepeating(`    element is not ${state} - waiting...`);\n            return continuePolling;\n          }\n\n          continue;\n        }\n\n        const element = this.retarget(node, 'no-follow-label');\n        if (!element) return 'error:notconnected'; // First raf happens in the same animation frame as evaluation, so it does not produce\n        // any client rect difference compared to synchronous call. We skip the synchronous call\n        // and only force layout during actual rafs as a small optimisation.\n\n        if (++counter === 1) return continuePolling; // Drop frames that are shorter than 16ms - WebKit Win bug.\n\n        const time = performance.now();\n        if (this._stableRafCount > 1 && time - lastTime < 15) return continuePolling;\n        lastTime = time;\n        const clientRect = element.getBoundingClientRect();\n        const rect = {\n          x: clientRect.top,\n          y: clientRect.left,\n          width: clientRect.width,\n          height: clientRect.height\n        };\n        const samePosition = lastRect && rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n        if (samePosition) ++samePositionCounter;else samePositionCounter = 0;\n        const isStable = samePositionCounter >= this._stableRafCount;\n        const isStableForLogs = isStable || !lastRect;\n        lastRect = rect;\n        if (!isStableForLogs) progress.logRepeating(`    element is not stable - waiting...`);\n        if (!isStable) return continuePolling;\n      }\n\n      return callback(node, progress, continuePolling);\n    };\n\n    if (this._replaceRafWithTimeout) return this.pollInterval(16, predicate);else return this.pollRaf(predicate);\n  }\n\n  checkElementState(node, state) {\n    const element = this.retarget(node, ['stable', 'visible', 'hidden'].includes(state) ? 'no-follow-label' : 'follow-label');\n\n    if (!element || !element.isConnected) {\n      if (state === 'hidden') return true;\n      return 'error:notconnected';\n    }\n\n    if (state === 'visible') return this.isVisible(element);\n    if (state === 'hidden') return !this.isVisible(element);\n    const disabled = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'].includes(element.nodeName) && element.hasAttribute('disabled');\n    if (state === 'disabled') return disabled;\n    if (state === 'enabled') return !disabled;\n    const editable = !(['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName) && element.hasAttribute('readonly'));\n    if (state === 'editable') return !disabled && editable;\n\n    if (state === 'checked') {\n      if (element.getAttribute('role') === 'checkbox') return element.getAttribute('aria-checked') === 'true';\n      if (element.nodeName !== 'INPUT') return 'error:notcheckbox';\n      if (!['radio', 'checkbox'].includes(element.type.toLowerCase())) return 'error:notcheckbox';\n      return element.checked;\n    }\n\n    throw new Error(`Unexpected element state \"${state}\"`);\n  }\n\n  selectOptions(optionsToSelect, node, progress, continuePolling) {\n    const element = this.retarget(node, 'follow-label');\n    if (!element) return 'error:notconnected';\n    if (element.nodeName.toLowerCase() !== 'select') return 'error:notselect';\n    const select = element;\n    const options = [...select.options];\n    const selectedOptions = [];\n    let remainingOptionsToSelect = optionsToSelect.slice();\n\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n\n      const filter = optionToSelect => {\n        if (optionToSelect instanceof Node) return option === optionToSelect;\n        let matches = true;\n        if (optionToSelect.value !== undefined) matches = matches && optionToSelect.value === option.value;\n        if (optionToSelect.label !== undefined) matches = matches && optionToSelect.label === option.label;\n        if (optionToSelect.index !== undefined) matches = matches && optionToSelect.index === index;\n        return matches;\n      };\n\n      if (!remainingOptionsToSelect.some(filter)) continue;\n      selectedOptions.push(option);\n\n      if (select.multiple) {\n        remainingOptionsToSelect = remainingOptionsToSelect.filter(o => !filter(o));\n      } else {\n        remainingOptionsToSelect = [];\n        break;\n      }\n    }\n\n    if (remainingOptionsToSelect.length) {\n      progress.logRepeating('    did not find some options - waiting... ');\n      return continuePolling;\n    }\n\n    select.value = undefined;\n    selectedOptions.forEach(option => option.selected = true);\n    progress.log('    selected specified option(s)');\n    select.dispatchEvent(new Event('input', {\n      'bubbles': true\n    }));\n    select.dispatchEvent(new Event('change', {\n      'bubbles': true\n    }));\n    return selectedOptions.map(option => option.value);\n  }\n\n  fill(value, node, progress) {\n    const element = this.retarget(node, 'follow-label');\n    if (!element) return 'error:notconnected';\n\n    if (element.nodeName.toLowerCase() === 'input') {\n      const input = element;\n      const type = input.type.toLowerCase();\n      const kDateTypes = new Set(['date', 'time', 'datetime', 'datetime-local', 'month', 'week']);\n      const kTextInputTypes = new Set(['', 'email', 'number', 'password', 'search', 'tel', 'text', 'url']);\n\n      if (!kTextInputTypes.has(type) && !kDateTypes.has(type)) {\n        progress.log(`    input of type \"${type}\" cannot be filled`);\n        return 'error:notfillableinputtype';\n      }\n\n      if (type === 'number') {\n        value = value.trim();\n        if (isNaN(Number(value))) return 'error:notfillablenumberinput';\n      }\n\n      if (kDateTypes.has(type)) {\n        value = value.trim();\n        input.focus();\n        input.value = value;\n        if (input.value !== value) return 'error:notvaliddate';\n        element.dispatchEvent(new Event('input', {\n          'bubbles': true\n        }));\n        element.dispatchEvent(new Event('change', {\n          'bubbles': true\n        }));\n        return 'done'; // We have already changed the value, no need to input it.\n      }\n    } else if (element.nodeName.toLowerCase() === 'textarea') {// Nothing to check here.\n    } else if (!element.isContentEditable) {\n      return 'error:notfillableelement';\n    }\n\n    this.selectText(element);\n    return 'needsinput'; // Still need to input the value.\n  }\n\n  selectText(node) {\n    const element = this.retarget(node, 'follow-label');\n    if (!element) return 'error:notconnected';\n\n    if (element.nodeName.toLowerCase() === 'input') {\n      const input = element;\n      input.select();\n      input.focus();\n      return 'done';\n    }\n\n    if (element.nodeName.toLowerCase() === 'textarea') {\n      const textarea = element;\n      textarea.selectionStart = 0;\n      textarea.selectionEnd = textarea.value.length;\n      textarea.focus();\n      return 'done';\n    }\n\n    const range = element.ownerDocument.createRange();\n    range.selectNodeContents(element);\n    const selection = element.ownerDocument.defaultView.getSelection();\n\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n\n    element.focus();\n    return 'done';\n  }\n\n  focusNode(node, resetSelectionIfNotFocused) {\n    if (!node.isConnected) return 'error:notconnected';\n    if (node.nodeType !== Node.ELEMENT_NODE) return 'error:notelement';\n    const wasFocused = node.getRootNode().activeElement === node && node.ownerDocument && node.ownerDocument.hasFocus();\n    node.focus();\n\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === 'input') {\n      try {\n        const input = node;\n        input.setSelectionRange(0, 0);\n      } catch (e) {// Some inputs do not allow selection.\n      }\n    }\n\n    return 'done';\n  }\n\n  setInputFiles(node, payloads) {\n    if (node.nodeType !== Node.ELEMENT_NODE) return 'Node is not of type HTMLElement';\n    const element = node;\n    if (element.nodeName !== 'INPUT') return 'Not an <input> element';\n    const input = element;\n    const type = (input.getAttribute('type') || '').toLowerCase();\n    if (type !== 'file') return 'Not an input[type=file] element';\n    const files = payloads.map(file => {\n      const bytes = Uint8Array.from(atob(file.buffer), c => c.charCodeAt(0));\n      return new File([bytes], file.name, {\n        type: file.mimeType\n      });\n    });\n    const dt = new DataTransfer();\n\n    for (const file of files) dt.items.add(file);\n\n    input.files = dt.files;\n    input.dispatchEvent(new Event('input', {\n      'bubbles': true\n    }));\n    input.dispatchEvent(new Event('change', {\n      'bubbles': true\n    }));\n  }\n\n  checkHitTargetAt(node, point) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element || !element.isConnected) return 'error:notconnected';\n    element = element.closest('button, [role=button]') || element;\n    let hitElement = this.deepElementFromPoint(document, point.x, point.y);\n    const hitParents = [];\n\n    while (hitElement && hitElement !== element) {\n      hitParents.push(hitElement);\n      hitElement = (0, _selectorEvaluator.parentElementOrShadowHost)(hitElement);\n    }\n\n    if (hitElement === element) return 'done';\n    const hitTargetDescription = this.previewNode(hitParents[0]); // Root is the topmost element in the hitTarget's chain that is not in the\n    // element's chain. For example, it might be a dialog element that overlays\n    // the target.\n\n    let rootHitTargetDescription;\n\n    while (element) {\n      const index = hitParents.indexOf(element);\n\n      if (index !== -1) {\n        if (index > 1) rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n        break;\n      }\n\n      element = (0, _selectorEvaluator.parentElementOrShadowHost)(element);\n    }\n\n    if (rootHitTargetDescription) return {\n      hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree`\n    };\n    return {\n      hitTargetDescription\n    };\n  }\n\n  dispatchEvent(node, type, eventInit) {\n    let event;\n    eventInit = {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      ...eventInit\n    };\n\n    switch (eventType.get(type)) {\n      case 'mouse':\n        event = new MouseEvent(type, eventInit);\n        break;\n\n      case 'keyboard':\n        event = new KeyboardEvent(type, eventInit);\n        break;\n\n      case 'touch':\n        event = new TouchEvent(type, eventInit);\n        break;\n\n      case 'pointer':\n        event = new PointerEvent(type, eventInit);\n        break;\n\n      case 'focus':\n        event = new FocusEvent(type, eventInit);\n        break;\n\n      case 'drag':\n        event = new DragEvent(type, eventInit);\n        break;\n\n      default:\n        event = new Event(type, eventInit);\n        break;\n    }\n\n    node.dispatchEvent(event);\n  }\n\n  deepElementFromPoint(document, x, y) {\n    let container = document;\n    let element;\n\n    while (container) {\n      // elementFromPoint works incorrectly in Chromium (http://crbug.com/1188919),\n      // so we use elementsFromPoint instead.\n      const elements = container.elementsFromPoint(x, y);\n      const innerElement = elements[0];\n      if (!innerElement || element === innerElement) break;\n      element = innerElement;\n      container = element.shadowRoot;\n    }\n\n    return element;\n  }\n\n  previewNode(node) {\n    if (node.nodeType === Node.TEXT_NODE) return oneLine(`#text=${node.nodeValue || ''}`);\n    if (node.nodeType !== Node.ELEMENT_NODE) return oneLine(`<${node.nodeName.toLowerCase()} />`);\n    const element = node;\n    const attrs = [];\n\n    for (let i = 0; i < element.attributes.length; i++) {\n      const {\n        name,\n        value\n      } = element.attributes[i];\n      if (name === 'style') continue;\n      if (!value && booleanAttributes.has(name)) attrs.push(` ${name}`);else attrs.push(` ${name}=\"${value}\"`);\n    }\n\n    attrs.sort((a, b) => a.length - b.length);\n    let attrText = attrs.join('');\n    if (attrText.length > 50) attrText = attrText.substring(0, 49) + '\\u2026';\n    if (autoClosingTags.has(element.nodeName)) return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n    const children = element.childNodes;\n    let onlyText = false;\n\n    if (children.length <= 5) {\n      onlyText = true;\n\n      for (let i = 0; i < children.length; i++) onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n    }\n\n    let text = onlyText ? element.textContent || '' : children.length ? '\\u2026' : '';\n    if (text.length > 50) text = text.substring(0, 49) + '\\u2026';\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${text}</${element.nodeName.toLowerCase()}>`);\n  }\n\n}\n\nexports.InjectedScript = InjectedScript;\nconst autoClosingTags = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'MENUITEM', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);\nconst booleanAttributes = new Set(['checked', 'selected', 'disabled', 'readonly', 'multiple']);\n\nfunction oneLine(s) {\n  return s.replace(/\\n/g, '').replace(/\\t/g, '');\n}\n\nconst eventType = new Map([['auxclick', 'mouse'], ['click', 'mouse'], ['dblclick', 'mouse'], ['mousedown', 'mouse'], ['mouseeenter', 'mouse'], ['mouseleave', 'mouse'], ['mousemove', 'mouse'], ['mouseout', 'mouse'], ['mouseover', 'mouse'], ['mouseup', 'mouse'], ['mouseleave', 'mouse'], ['mousewheel', 'mouse'], ['keydown', 'keyboard'], ['keyup', 'keyboard'], ['keypress', 'keyboard'], ['textInput', 'keyboard'], ['touchstart', 'touch'], ['touchmove', 'touch'], ['touchend', 'touch'], ['touchcancel', 'touch'], ['pointerover', 'pointer'], ['pointerout', 'pointer'], ['pointerenter', 'pointer'], ['pointerleave', 'pointer'], ['pointerdown', 'pointer'], ['pointerup', 'pointer'], ['pointermove', 'pointer'], ['pointercancel', 'pointer'], ['gotpointercapture', 'pointer'], ['lostpointercapture', 'pointer'], ['focus', 'focus'], ['blur', 'focus'], ['drag', 'drag'], ['dragstart', 'drag'], ['dragend', 'drag'], ['dragover', 'drag'], ['dragenter', 'drag'], ['dragleave', 'drag'], ['dragexit', 'drag'], ['drop', 'drag']]);\n\nfunction unescape(s) {\n  if (!s.includes('\\\\')) return s;\n  const r = [];\n  let i = 0;\n\n  while (i < s.length) {\n    if (s[i] === '\\\\' && i + 1 < s.length) i++;\n    r.push(s[i++]);\n  }\n\n  return r.join('');\n}\n\nfunction createTextMatcher(selector) {\n  if (selector[0] === '/' && selector.lastIndexOf('/') > 0) {\n    const lastSlash = selector.lastIndexOf('/');\n    const matcher = (0, _selectorEvaluator.createRegexTextMatcher)(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n    return {\n      matcher,\n      kind: 'regex'\n    };\n  }\n\n  let strict = false;\n\n  if (selector.length > 1 && selector[0] === '\"' && selector[selector.length - 1] === '\"') {\n    selector = unescape(selector.substring(1, selector.length - 1));\n    strict = true;\n  }\n\n  if (selector.length > 1 && selector[0] === \"'\" && selector[selector.length - 1] === \"'\") {\n    selector = unescape(selector.substring(1, selector.length - 1));\n    strict = true;\n  }\n\n  const matcher = strict ? (0, _selectorEvaluator.createStrictTextMatcher)(selector) : (0, _selectorEvaluator.createLaxTextMatcher)(selector);\n  return {\n    matcher,\n    kind: strict ? 'strict' : 'lax'\n  };\n}\n\nvar _default = InjectedScript;\nexports.default = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./src/server/injected/selectorEvaluator.ts\":\n/*!**************************************************!*\\\n  !*** ./src/server/injected/selectorEvaluator.ts ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLaxTextMatcher = createLaxTextMatcher;\nexports.createStrictTextMatcher = createStrictTextMatcher;\nexports.createRegexTextMatcher = createRegexTextMatcher;\nexports.elementText = elementText;\nexports.elementMatchesText = elementMatchesText;\nexports.parentElementOrShadowHost = parentElementOrShadowHost;\nexports.isVisible = isVisible;\nexports.SelectorEvaluatorImpl = void 0;\n\nvar _selectorParser = __webpack_require__(/*! ../common/selectorParser */ \"./src/server/common/selectorParser.ts\");\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass SelectorEvaluatorImpl {\n  constructor(extraEngines) {\n    this._engines = new Map();\n    this._cacheQueryCSS = new Map();\n    this._cacheMatches = new Map();\n    this._cacheQuery = new Map();\n    this._cacheMatchesSimple = new Map();\n    this._cacheMatchesParents = new Map();\n    this._cacheCallMatches = new Map();\n    this._cacheCallQuery = new Map();\n    this._cacheQuerySimple = new Map();\n    this._cacheText = new Map();\n    this._scoreMap = void 0;\n    this._retainCacheCounter = 0;\n\n    for (const [name, engine] of extraEngines) this._engines.set(name, engine);\n\n    this._engines.set('not', notEngine);\n\n    this._engines.set('is', isEngine);\n\n    this._engines.set('where', isEngine);\n\n    this._engines.set('has', hasEngine);\n\n    this._engines.set('scope', scopeEngine);\n\n    this._engines.set('light', lightEngine);\n\n    this._engines.set('visible', visibleEngine);\n\n    this._engines.set('text', textEngine);\n\n    this._engines.set('text-is', textIsEngine);\n\n    this._engines.set('text-matches', textMatchesEngine);\n\n    this._engines.set('has-text', hasTextEngine);\n\n    this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));\n\n    this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));\n\n    this._engines.set('above', createPositionEngine('above', boxAbove));\n\n    this._engines.set('below', createPositionEngine('below', boxBelow));\n\n    this._engines.set('near', createPositionEngine('near', boxNear));\n\n    this._engines.set('nth-match', nthMatchEngine);\n\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [..._selectorParser.customCSSNames];\n    parserNames.sort();\n    if (allNames.join('|') !== parserNames.join('|')) throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join('|')} vs ${parserNames.join('|')}`);\n  }\n\n  begin() {\n    ++this._retainCacheCounter;\n  }\n\n  end() {\n    --this._retainCacheCounter;\n\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n\n      this._cacheMatches.clear();\n\n      this._cacheQuery.clear();\n\n      this._cacheMatchesSimple.clear();\n\n      this._cacheMatchesParents.clear();\n\n      this._cacheCallMatches.clear();\n\n      this._cacheCallQuery.clear();\n\n      this._cacheQuerySimple.clear();\n\n      this._cacheText.clear();\n    }\n  }\n\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main)) cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));\n    if (entry) return entry.result;\n    const result = cb();\n    entries.push({\n      rest,\n      result\n    });\n    return result;\n  }\n\n  _checkSelector(s) {\n    const wellFormed = typeof s === 'object' && s && (Array.isArray(s) || 'simples' in s && s.simples.length);\n    if (!wellFormed) throw new Error(`Malformed selector \"${s}\"`);\n    return s;\n  }\n\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n\n    this.begin();\n\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\n        if (Array.isArray(selector)) return this._matchesEngine(isEngine, element, selector, context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context)) return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n\n  query(context, s) {\n    const selector = this._checkSelector(s);\n\n    this.begin();\n\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\n        if (Array.isArray(selector)) return this._queryEngine(isEngine, context, selector); // query() recursively calls itself, so we set up a new map for this particular query() call.\n\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = new Map();\n\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n\n        elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));\n\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n\n            const bScore = this._scoreMap.get(b);\n\n            if (aScore === bScore) return 0;\n            if (aScore === undefined) return 1;\n            if (bScore === undefined) return -1;\n            return aScore - bScore;\n          });\n        }\n\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n\n  _markScore(element, score) {\n    // HACK ALERT: temporary marks an element with a score, to be used\n    // for sorting at the end of the query().\n    if (this._scoreMap) this._scoreMap.set(element, score);\n  }\n\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\n      const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');\n      if (!isPossiblyScopeClause && element === context.scope) return false;\n      if (simple.css && !this._matchesCSS(element, simple.css)) return false;\n\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context)) return false;\n      }\n\n      return true;\n    });\n  }\n\n  _querySimple(context, simple) {\n    if (!simple.functions.length) return this._queryCSS(context, simple.css || '*');\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\n      let css = simple.css;\n      const funcs = simple.functions;\n      if (css === '*' && funcs.length) css = undefined;\n      let elements;\n      let firstIndex = -1;\n\n      if (css !== undefined) {\n        elements = this._queryCSS(context, css);\n      } else {\n        firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);\n        if (firstIndex === -1) firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex) continue;\n\n        const engine = this._getEngine(funcs[i].name);\n\n        if (engine.matches !== undefined) elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex) continue;\n\n        const engine = this._getEngine(funcs[i].name);\n\n        if (engine.matches === undefined) elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n\n      return elements;\n    });\n  }\n\n  _matchesParents(element, complex, index, context) {\n    if (index < 0) return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\n      const {\n        selector: simple,\n        combinator\n      } = complex.simples[index];\n\n      if (combinator === '>') {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context)) return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n\n      if (combinator === '+') {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context)) return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n\n      if (combinator === '') {\n        let parent = parentElementOrShadowHostInContext(element, context);\n\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context)) return true;\n            if (complex.simples[index - 1].combinator === '') break;\n          }\n\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n\n        return false;\n      }\n\n      if (combinator === '~') {\n        let previousSibling = previousSiblingInContext(element, context);\n\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context)) return true;\n            if (complex.simples[index - 1].combinator === '~') break;\n          }\n\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n\n        return false;\n      }\n\n      if (combinator === '>=') {\n        let parent = element;\n\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context)) return true;\n            if (complex.simples[index - 1].combinator === '') break;\n          }\n\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n\n        return false;\n      }\n\n      throw new Error(`Unsupported combinator \"${combinator}\"`);\n    });\n  }\n\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches) return this._callMatches(engine, element, args, context);\n    if (engine.query) return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n  }\n\n  _queryEngine(engine, context, args) {\n    if (engine.query) return this._callQuery(engine, args, context);\n    if (engine.matches) return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n  }\n\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n\n  _matchesCSS(element, css) {\n    return element.matches(css);\n  }\n\n  _queryCSS(context, css) {\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {\n      let result = [];\n\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css)]);\n        if (!context.pierceShadow) return;\n        if (root.shadowRoot) query(root.shadowRoot);\n\n        for (const element of root.querySelectorAll('*')) {\n          if (element.shadowRoot) query(element.shadowRoot);\n        }\n      }\n\n      query(context.scope);\n      return result;\n    });\n  }\n\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n\n    if (!engine) throw new Error(`Unknown selector engine \"${name}\"`);\n    return engine;\n  }\n\n}\n\nexports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;\nconst isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0) throw new Error(`\"is\" engine expects non-empty selector list`);\n    return args.some(selector => evaluator.matches(element, selector, context));\n  },\n\n  query(context, args, evaluator) {\n    if (args.length === 0) throw new Error(`\"is\" engine expects non-empty selector list`);\n    let elements = [];\n\n    for (const arg of args) elements = elements.concat(evaluator.query(context, arg));\n\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n\n};\nconst hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0) throw new Error(`\"has\" engine expects non-empty selector list`);\n    return evaluator.query({ ...context,\n      scope: element\n    }, args).length > 0;\n  } // TODO: we do not implement \"relative selectors\", as in \"div:has(> span)\" or \"div:has(+ span)\".\n  // TODO: we can implement efficient \"query\" by matching \"args\" and returning\n  // all parents/descendants, just have to be careful with the \":scope\" matching.\n\n\n};\nconst scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0) throw new Error(`\"scope\" engine expects no arguments`);\n    if (context.scope.nodeType === 9\n    /* Node.DOCUMENT_NODE */\n    ) return element === context.scope.documentElement;\n    return element === context.scope;\n  },\n\n  query(context, args, evaluator) {\n    if (args.length !== 0) throw new Error(`\"scope\" engine expects no arguments`);\n\n    if (context.scope.nodeType === 9\n    /* Node.DOCUMENT_NODE */\n    ) {\n        const root = context.scope.documentElement;\n        return root ? [root] : [];\n      }\n\n    if (context.scope.nodeType === 1\n    /* Node.ELEMENT_NODE */\n    ) return [context.scope];\n    return [];\n  }\n\n};\nconst notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0) throw new Error(`\"not\" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n\n};\nconst lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context,\n      pierceShadow: false\n    }, args);\n  },\n\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context,\n      pierceShadow: false\n    });\n  }\n\n};\nconst visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length) throw new Error(`\"visible\" engine expects no arguments`);\n    return isVisible(element);\n  }\n\n};\nconst textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== 'string') throw new Error(`\"text\" engine expects a single string`);\n    const matcher = createLaxTextMatcher(args[0]);\n    return elementMatchesText(evaluator, element, matcher) === 'self';\n  }\n\n};\nconst textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== 'string') throw new Error(`\"text-is\" engine expects a single string`);\n    const matcher = createStrictTextMatcher(args[0]);\n    return elementMatchesText(evaluator, element, matcher) !== 'none';\n  }\n\n};\nconst textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || args.length === 2 && typeof args[1] !== 'string') throw new Error(`\"text-matches\" engine expects a regexp body and optional regexp flags`);\n    const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);\n    return elementMatchesText(evaluator, element, matcher) === 'self';\n  }\n\n};\nconst hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== 'string') throw new Error(`\"has-text\" engine expects a single string`);\n    if (shouldSkipForTextMatching(element)) return false;\n    const matcher = createLaxTextMatcher(args[0]);\n    return matcher(elementText(evaluator, element));\n  }\n\n};\n\nfunction createLaxTextMatcher(text) {\n  text = text.trim().replace(/\\s+/g, ' ').toLowerCase();\n  return elementText => {\n    const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();\n    return s.includes(text);\n  };\n}\n\nfunction createStrictTextMatcher(text) {\n  text = text.trim().replace(/\\s+/g, ' ');\n  return elementText => {\n    return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);\n  };\n}\n\nfunction createRegexTextMatcher(source, flags) {\n  const re = new RegExp(source, flags);\n  return elementText => {\n    return re.test(elementText.full);\n  };\n}\n\nfunction shouldSkipForTextMatching(element) {\n  return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);\n}\n\nfunction elementText(evaluator, root) {\n  let value = evaluator._cacheText.get(root);\n\n  if (value === undefined) {\n    value = {\n      full: '',\n      immediate: []\n    };\n\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = '';\n\n      if (root instanceof HTMLInputElement && (root.type === 'submit' || root.type === 'button')) {\n        value = {\n          full: root.value,\n          immediate: [root.value]\n        };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || '';\n            currentImmediate += child.nodeValue || '';\n          } else {\n            if (currentImmediate) value.immediate.push(currentImmediate);\n            currentImmediate = '';\n            if (child.nodeType === Node.ELEMENT_NODE) value.full += elementText(evaluator, child).full;\n          }\n        }\n\n        if (currentImmediate) value.immediate.push(currentImmediate);\n        if (root.shadowRoot) value.full += elementText(evaluator, root.shadowRoot).full;\n      }\n    }\n\n    evaluator._cacheText.set(root, value);\n  }\n\n  return value;\n}\n\nfunction elementMatchesText(evaluator, element, matcher) {\n  if (shouldSkipForTextMatching(element)) return 'none';\n  if (!matcher(elementText(evaluator, element))) return 'none';\n\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child))) return 'selfAndChildren';\n  }\n\n  if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot))) return 'selfAndChildren';\n  return 'self';\n}\n\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== undefined && distance > maxDistance) return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\n\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== undefined && distance > maxDistance) return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\n\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== undefined && distance > maxDistance) return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\n\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== undefined && distance > maxDistance) return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\n\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === undefined ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0) score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0) score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0) score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0) score += box1.top - box2.bottom;\n  return score > kThreshold ? undefined : score;\n}\n\nfunction createPositionEngine(name, scorer) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;\n      const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === undefined ? 0 : 1)) throw new Error(`\"${name}\" engine expects a selector list and optional maximum distance in pixels`);\n      const box = element.getBoundingClientRect();\n      let bestScore;\n\n      for (const e of evaluator.query(context, queryArgs)) {\n        if (e === element) continue;\n        const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n        if (score === undefined) continue;\n        if (bestScore === undefined || score < bestScore) bestScore = score;\n      }\n\n      if (bestScore === undefined) return false;\n\n      evaluator._markScore(element, bestScore);\n\n      return true;\n    }\n\n  };\n}\n\nconst nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2) throw new Error(`\"nth-match\" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== 'number' || index < 1) throw new Error(`\"nth-match\" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--; // one-based\n\n    return index < elements.length ? [elements[index]] : [];\n  }\n\n};\n\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement) return element.parentElement;\n  if (!element.parentNode) return;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host) return element.parentNode.host;\n}\n\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope) return;\n  if (!context.pierceShadow) return element.parentElement || undefined;\n  return parentElementOrShadowHost(element);\n}\n\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope) return;\n  return element.previousElementSibling || undefined;\n}\n\nfunction isVisible(element) {\n  // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.\n  if (!element.ownerDocument || !element.ownerDocument.defaultView) return true;\n  const style = element.ownerDocument.defaultView.getComputedStyle(element);\n  if (!style || style.visibility === 'hidden') return false;\n  const rect = element.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\n\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = new Map();\n  const roots = [];\n  const result = [];\n\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry) return entry;\n    const parent = parentElementOrShadowHost(element);\n\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n\n    entry = {\n      children: [],\n      taken: false\n    };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n\n  elements.forEach(e => append(e).taken = true);\n\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken) result.push(element);\n\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n\n      while (child && entry.children.length < set.size) {\n        if (set.has(child)) entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n\n      while (child && entry.children.length < set.size) {\n        if (set.has(child)) entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n\n    entry.children.forEach(visit);\n  }\n\n  roots.forEach(visit);\n  return result;\n}\n\n/***/ }),\n\n/***/ \"./src/server/injected/xpathSelectorEngine.ts\":\n/*!****************************************************!*\\\n  !*** ./src/server/injected/xpathSelectorEngine.ts ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XPathEngine = void 0;\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst XPathEngine = {\n  query(root, selector) {\n    if (selector.startsWith('/')) selector = '.' + selector;\n    const document = root instanceof Document ? root : root.ownerDocument;\n    if (!document) return;\n    const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE) return node;\n    }\n  },\n\n  queryAll(root, selector) {\n    if (selector.startsWith('/')) selector = '.' + selector;\n    const result = [];\n    const document = root instanceof Document ? root : root.ownerDocument;\n    if (!document) return result;\n    const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE) result.push(node);\n    }\n\n    return result;\n  }\n\n};\nexports.XPathEngine = XPathEngine;\n\n/***/ })\n\n/******/ })[\"default\"];";
exports.source = source;
//# sourceMappingURL=injectedScriptSource.js.map