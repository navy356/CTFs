"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.source = void 0;
const source = "var pwExport =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/server/supplements/injected/recorder.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/server/common/cssParser.ts\":\n/*!****************************************!*\\\n  !*** ./src/server/common/cssParser.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseCSS = parseCSS;\nexports.serializeSelector = serializeSelector;\n\nvar css = _interopRequireWildcard(__webpack_require__(/*! ./cssTokenizer */ \"./src/server/common/cssTokenizer.js\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction parseCSS(selector, customNames) {\n  let tokens;\n\n  try {\n    tokens = css.tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof css.EOFToken)) tokens.push(new css.EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing selector \"${selector}\"`;\n    const index = (e.stack || '').indexOf(e.message);\n    if (index !== -1) e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n\n  const unsupportedToken = tokens.find(token => {\n    return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.\n    // For example :xpath{ (//div/bar[@attr=\"foo\"])[2]/baz }\n    // Or this way :xpath( {complex-xpath-goes-here(\"hello\")} )\n    token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken || // TODO: Consider treating these as strings?\n    token instanceof css.URLToken || token instanceof css.PercentageToken;\n  });\n  if (unsupportedToken) throw new Error(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing selector \"${selector}\"`);\n  let pos = 0;\n  const names = new Set();\n\n  function unexpected() {\n    return new Error(`Unexpected token \"${tokens[pos].toSource()}\" while parsing selector \"${selector}\"`);\n  }\n\n  function skipWhitespace() {\n    while (tokens[pos] instanceof css.WhitespaceToken) pos++;\n  }\n\n  function isIdent(p = pos) {\n    return tokens[p] instanceof css.IdentToken;\n  }\n\n  function isString(p = pos) {\n    return tokens[p] instanceof css.StringToken;\n  }\n\n  function isNumber(p = pos) {\n    return tokens[p] instanceof css.NumberToken;\n  }\n\n  function isComma(p = pos) {\n    return tokens[p] instanceof css.CommaToken;\n  }\n\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof css.CloseParenToken;\n  }\n\n  function isStar(p = pos) {\n    return tokens[p] instanceof css.DelimToken && tokens[p].value === '*';\n  }\n\n  function isEOF(p = pos) {\n    return tokens[p] instanceof css.EOFToken;\n  }\n\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof css.DelimToken && ['>', '+', '~'].includes(tokens[p].value);\n  }\n\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;\n  }\n\n  function consumeFunctionArguments() {\n    const result = [consumeArgument()];\n\n    while (true) {\n      skipWhitespace();\n      if (!isComma()) break;\n      pos++;\n      result.push(consumeArgument());\n    }\n\n    return result;\n  }\n\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber()) return tokens[pos++].value;\n    if (isString()) return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n\n  function consumeComplexSelector() {\n    skipWhitespace();\n    const result = {\n      simples: [{\n        selector: consumeSimpleSelector(),\n        combinator: ''\n      }]\n    };\n\n    while (true) {\n      skipWhitespace();\n\n      if (isClauseCombinator()) {\n        result.simples[result.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n\n      result.simples.push({\n        combinator: '',\n        selector: consumeSimpleSelector()\n      });\n    }\n\n    return result;\n  }\n\n  function consumeSimpleSelector() {\n    let rawCSSString = '';\n    const functions = [];\n\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === '.') {\n        pos++;\n        if (isIdent()) rawCSSString += '.' + tokens[pos++].toSource();else throw unexpected();\n      } else if (tokens[pos] instanceof css.ColonToken) {\n        pos++;\n\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ':' + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({\n              name,\n              args: []\n            });\n            names.add(name);\n          }\n        } else if (tokens[pos] instanceof css.FunctionToken) {\n          const name = tokens[pos++].value.toLowerCase();\n\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({\n              name,\n              args: consumeFunctionArguments()\n            });\n            names.add(name);\n          }\n\n          skipWhitespace();\n          if (!isCloseParen()) throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof css.OpenSquareToken) {\n        rawCSSString += '[';\n        pos++;\n\n        while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF()) rawCSSString += tokens[pos++].toSource();\n\n        if (!(tokens[pos] instanceof css.CloseSquareToken)) throw unexpected();\n        rawCSSString += ']';\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n\n    if (!rawCSSString && !functions.length) throw unexpected();\n    return {\n      css: rawCSSString || undefined,\n      functions\n    };\n  }\n\n  function consumeBuiltinFunctionArguments() {\n    let s = '';\n\n    while (!isCloseParen() && !isEOF()) s += tokens[pos++].toSource();\n\n    return s;\n  }\n\n  const result = consumeFunctionArguments();\n  if (!isEOF()) throw new Error(`Error while parsing selector \"${selector}\"`);\n  if (result.some(arg => typeof arg !== 'object' || !('simples' in arg))) throw new Error(`Error while parsing selector \"${selector}\"`);\n  return {\n    selector: result,\n    names: Array.from(names)\n  };\n}\n\nfunction serializeSelector(args) {\n  return args.map(arg => {\n    if (typeof arg === 'string') return `\"${arg}\"`;\n    if (typeof arg === 'number') return String(arg);\n    return arg.simples.map(({\n      selector,\n      combinator\n    }) => {\n      let s = selector.css || '';\n      s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');\n      if (combinator) s += ' ' + combinator;\n      return s;\n    }).join(' ');\n  }).join(', ');\n}\n\n/***/ }),\n\n/***/ \"./src/server/common/cssTokenizer.js\":\n/*!*******************************************!*\\\n  !*** ./src/server/common/cssTokenizer.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n/*\n * Original at https://github.com/tabatkins/parse-css\n * licensed under http://creativecommons.org/publicdomain/zero/1.0/\n *\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Changes from https://github.com/tabatkins/parse-css\n//   - Tabs are replaced with two spaces.\n//   - Everything not related to tokenizing - below the first exports block - is removed.\n// @ts-nocheck\n(function (root, factory) {\n  // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(void 0, function (exports) {\n  var between = function (num, first, last) {\n    return num >= first && num <= last;\n  };\n\n  function digit(code) {\n    return between(code, 0x30, 0x39);\n  }\n\n  function hexdigit(code) {\n    return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66);\n  }\n\n  function uppercaseletter(code) {\n    return between(code, 0x41, 0x5a);\n  }\n\n  function lowercaseletter(code) {\n    return between(code, 0x61, 0x7a);\n  }\n\n  function letter(code) {\n    return uppercaseletter(code) || lowercaseletter(code);\n  }\n\n  function nonascii(code) {\n    return code >= 0x80;\n  }\n\n  function namestartchar(code) {\n    return letter(code) || nonascii(code) || code == 0x5f;\n  }\n\n  function namechar(code) {\n    return namestartchar(code) || digit(code) || code == 0x2d;\n  }\n\n  function nonprintable(code) {\n    return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f;\n  }\n\n  function newline(code) {\n    return code == 0xa;\n  }\n\n  function whitespace(code) {\n    return newline(code) || code == 9 || code == 0x20;\n  }\n\n  function badescape(code) {\n    return newline(code) || isNaN(code);\n  }\n\n  var maximumallowedcodepoint = 0x10ffff;\n\n  var InvalidCharacterError = function (message) {\n    this.message = message;\n  };\n\n  InvalidCharacterError.prototype = new Error();\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  function preprocess(str) {\n    // Turn a string into an array of code points,\n    // following the preprocessing cleanup rules.\n    var codepoints = [];\n\n    for (var i = 0; i < str.length; i++) {\n      var code = str.charCodeAt(i);\n\n      if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {\n        code = 0xa;\n        i++;\n      }\n\n      if (code == 0xd || code == 0xc) code = 0xa;\n      if (code == 0x0) code = 0xfffd;\n\n      if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {\n        // Decode a surrogate pair into an astral codepoint.\n        var lead = code - 0xd800;\n        var trail = str.charCodeAt(i + 1) - 0xdc00;\n        code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n        i++;\n      }\n\n      codepoints.push(code);\n    }\n\n    return codepoints;\n  }\n\n  function stringFromCode(code) {\n    if (code <= 0xffff) return String.fromCharCode(code); // Otherwise, encode astral char as surrogate pair.\n\n    code -= Math.pow(2, 16);\n    var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;\n    var trail = code % Math.pow(2, 10) + 0xdc00;\n    return String.fromCharCode(lead) + String.fromCharCode(trail);\n  }\n\n  function tokenize(str) {\n    str = preprocess(str);\n    var i = -1;\n    var tokens = [];\n    var code; // Line number information.\n\n    var line = 0;\n    var column = 0; // The only use of lastLineLength is in reconsume().\n\n    var lastLineLength = 0;\n\n    var incrLineno = function () {\n      line += 1;\n      lastLineLength = column;\n      column = 0;\n    };\n\n    var locStart = {\n      line: line,\n      column: column\n    };\n\n    var codepoint = function (i) {\n      if (i >= str.length) {\n        return -1;\n      }\n\n      return str[i];\n    };\n\n    var next = function (num) {\n      if (num === undefined) num = 1;\n      if (num > 3) throw \"Spec Error: no more than three codepoints of lookahead.\";\n      return codepoint(i + num);\n    };\n\n    var consume = function (num) {\n      if (num === undefined) num = 1;\n      i += num;\n      code = codepoint(i);\n      if (newline(code)) incrLineno();else column += num; //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n\n      return true;\n    };\n\n    var reconsume = function () {\n      i -= 1;\n\n      if (newline(code)) {\n        line -= 1;\n        column = lastLineLength;\n      } else {\n        column -= 1;\n      }\n\n      locStart.line = line;\n      locStart.column = column;\n      return true;\n    };\n\n    var eof = function (codepoint) {\n      if (codepoint === undefined) codepoint = code;\n      return codepoint == -1;\n    };\n\n    var donothing = function () {};\n\n    var parseerror = function () {\n      console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");\n      return true;\n    };\n\n    var consumeAToken = function () {\n      consumeComments();\n      consume();\n\n      if (whitespace(code)) {\n        while (whitespace(next())) consume();\n\n        return new WhitespaceToken();\n      } else if (code == 0x22) return consumeAStringToken();else if (code == 0x23) {\n        if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n          var token = new HashToken();\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = \"id\";\n          token.value = consumeAName();\n          return token;\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x24) {\n        if (next() == 0x3d) {\n          consume();\n          return new SuffixMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x27) return consumeAStringToken();else if (code == 0x28) return new OpenParenToken();else if (code == 0x29) return new CloseParenToken();else if (code == 0x2a) {\n        if (next() == 0x3d) {\n          consume();\n          return new SubstringMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x2b) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x2c) return new CommaToken();else if (code == 0x2d) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else if (next(1) == 0x2d && next(2) == 0x3e) {\n          consume(2);\n          return new CDCToken();\n        } else if (startsWithAnIdentifier()) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x2e) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x3a) return new ColonToken();else if (code == 0x3b) return new SemicolonToken();else if (code == 0x3c) {\n        if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n          consume(3);\n          return new CDOToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x40) {\n        if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n          return new AtKeywordToken(consumeAName());\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x5b) return new OpenSquareToken();else if (code == 0x5c) {\n        if (startsWithAValidEscape()) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else {\n          parseerror();\n          return new DelimToken(code);\n        }\n      } else if (code == 0x5d) return new CloseSquareToken();else if (code == 0x5e) {\n        if (next() == 0x3d) {\n          consume();\n          return new PrefixMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x7b) return new OpenCurlyToken();else if (code == 0x7c) {\n        if (next() == 0x3d) {\n          consume();\n          return new DashMatchToken();\n        } else if (next() == 0x7c) {\n          consume();\n          return new ColumnToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code == 0x7d) return new CloseCurlyToken();else if (code == 0x7e) {\n        if (next() == 0x3d) {\n          consume();\n          return new IncludeMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (digit(code)) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (namestartchar(code)) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else if (eof()) return new EOFToken();else return new DelimToken(code);\n    };\n\n    var consumeComments = function () {\n      while (next(1) == 0x2f && next(2) == 0x2a) {\n        consume(2);\n\n        while (true) {\n          consume();\n\n          if (code == 0x2a && next() == 0x2f) {\n            consume();\n            break;\n          } else if (eof()) {\n            parseerror();\n            return;\n          }\n        }\n      }\n    };\n\n    var consumeANumericToken = function () {\n      var num = consumeANumber();\n\n      if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n        var token = new DimensionToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        token.type = num.type;\n        token.unit = consumeAName();\n        return token;\n      } else if (next() == 0x25) {\n        consume();\n        var token = new PercentageToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        return token;\n      } else {\n        var token = new NumberToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        token.type = num.type;\n        return token;\n      }\n    };\n\n    var consumeAnIdentlikeToken = function () {\n      var str = consumeAName();\n\n      if (str.toLowerCase() == \"url\" && next() == 0x28) {\n        consume();\n\n        while (whitespace(next(1)) && whitespace(next(2))) consume();\n\n        if (next() == 0x22 || next() == 0x27) {\n          return new FunctionToken(str);\n        } else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n          return new FunctionToken(str);\n        } else {\n          return consumeAURLToken();\n        }\n      } else if (next() == 0x28) {\n        consume();\n        return new FunctionToken(str);\n      } else {\n        return new IdentToken(str);\n      }\n    };\n\n    var consumeAStringToken = function (endingCodePoint) {\n      if (endingCodePoint === undefined) endingCodePoint = code;\n      var string = \"\";\n\n      while (consume()) {\n        if (code == endingCodePoint || eof()) {\n          return new StringToken(string);\n        } else if (newline(code)) {\n          parseerror();\n          reconsume();\n          return new BadStringToken();\n        } else if (code == 0x5c) {\n          if (eof(next())) {\n            donothing();\n          } else if (newline(next())) {\n            consume();\n          } else {\n            string += stringFromCode(consumeEscape());\n          }\n        } else {\n          string += stringFromCode(code);\n        }\n      }\n    };\n\n    var consumeAURLToken = function () {\n      var token = new URLToken(\"\");\n\n      while (whitespace(next())) consume();\n\n      if (eof(next())) return token;\n\n      while (consume()) {\n        if (code == 0x29 || eof()) {\n          return token;\n        } else if (whitespace(code)) {\n          while (whitespace(next())) consume();\n\n          if (next() == 0x29 || eof(next())) {\n            consume();\n            return token;\n          } else {\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken();\n          }\n        } else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        } else if (code == 0x5c) {\n          if (startsWithAValidEscape()) {\n            token.value += stringFromCode(consumeEscape());\n          } else {\n            parseerror();\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken();\n          }\n        } else {\n          token.value += stringFromCode(code);\n        }\n      }\n    };\n\n    var consumeEscape = function () {\n      // Assume the the current character is the \\\n      // and the next code point is not a newline.\n      consume();\n\n      if (hexdigit(code)) {\n        // Consume 1-6 hex digits\n        var digits = [code];\n\n        for (var total = 0; total < 5; total++) {\n          if (hexdigit(next())) {\n            consume();\n            digits.push(code);\n          } else {\n            break;\n          }\n        }\n\n        if (whitespace(next())) consume();\n        var value = parseInt(digits.map(function (x) {\n          return String.fromCharCode(x);\n        }).join(''), 16);\n        if (value > maximumallowedcodepoint) value = 0xfffd;\n        return value;\n      } else if (eof()) {\n        return 0xfffd;\n      } else {\n        return code;\n      }\n    };\n\n    var areAValidEscape = function (c1, c2) {\n      if (c1 != 0x5c) return false;\n      if (newline(c2)) return false;\n      return true;\n    };\n\n    var startsWithAValidEscape = function () {\n      return areAValidEscape(code, next());\n    };\n\n    var wouldStartAnIdentifier = function (c1, c2, c3) {\n      if (c1 == 0x2d) {\n        return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n      } else if (namestartchar(c1)) {\n        return true;\n      } else if (c1 == 0x5c) {\n        return areAValidEscape(c1, c2);\n      } else {\n        return false;\n      }\n    };\n\n    var startsWithAnIdentifier = function () {\n      return wouldStartAnIdentifier(code, next(1), next(2));\n    };\n\n    var wouldStartANumber = function (c1, c2, c3) {\n      if (c1 == 0x2b || c1 == 0x2d) {\n        if (digit(c2)) return true;\n        if (c2 == 0x2e && digit(c3)) return true;\n        return false;\n      } else if (c1 == 0x2e) {\n        if (digit(c2)) return true;\n        return false;\n      } else if (digit(c1)) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    var startsWithANumber = function () {\n      return wouldStartANumber(code, next(1), next(2));\n    };\n\n    var consumeAName = function () {\n      var result = \"\";\n\n      while (consume()) {\n        if (namechar(code)) {\n          result += stringFromCode(code);\n        } else if (startsWithAValidEscape()) {\n          result += stringFromCode(consumeEscape());\n        } else {\n          reconsume();\n          return result;\n        }\n      }\n    };\n\n    var consumeANumber = function () {\n      var repr = [];\n      var type = \"integer\";\n\n      if (next() == 0x2b || next() == 0x2d) {\n        consume();\n        repr += stringFromCode(code);\n      }\n\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n\n      if (next(1) == 0x2e && digit(next(2))) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = \"number\";\n\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      }\n\n      var c1 = next(1),\n          c2 = next(2),\n          c3 = next(3);\n\n      if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = \"number\";\n\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      } else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = \"number\";\n\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      }\n\n      var value = convertAStringToANumber(repr);\n      return {\n        type: type,\n        value: value,\n        repr: repr\n      };\n    };\n\n    var convertAStringToANumber = function (string) {\n      // CSS's number rules are identical to JS, afaik.\n      return +string;\n    };\n\n    var consumeTheRemnantsOfABadURL = function () {\n      while (consume()) {\n        if (code == 0x29 || eof()) {\n          return;\n        } else if (startsWithAValidEscape()) {\n          consumeEscape();\n          donothing();\n        } else {\n          donothing();\n        }\n      }\n    };\n\n    var iterationCount = 0;\n\n    while (!eof(next())) {\n      tokens.push(consumeAToken());\n      iterationCount++;\n      if (iterationCount > str.length * 2) return \"I'm infinite-looping!\";\n    }\n\n    return tokens;\n  }\n\n  function CSSParserToken() {\n    throw \"Abstract Base Class\";\n  }\n\n  CSSParserToken.prototype.toJSON = function () {\n    return {\n      token: this.tokenType\n    };\n  };\n\n  CSSParserToken.prototype.toString = function () {\n    return this.tokenType;\n  };\n\n  CSSParserToken.prototype.toSource = function () {\n    return '' + this;\n  };\n\n  function BadStringToken() {\n    return this;\n  }\n\n  BadStringToken.prototype = Object.create(CSSParserToken.prototype);\n  BadStringToken.prototype.tokenType = \"BADSTRING\";\n\n  function BadURLToken() {\n    return this;\n  }\n\n  BadURLToken.prototype = Object.create(CSSParserToken.prototype);\n  BadURLToken.prototype.tokenType = \"BADURL\";\n\n  function WhitespaceToken() {\n    return this;\n  }\n\n  WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);\n  WhitespaceToken.prototype.tokenType = \"WHITESPACE\";\n\n  WhitespaceToken.prototype.toString = function () {\n    return \"WS\";\n  };\n\n  WhitespaceToken.prototype.toSource = function () {\n    return \" \";\n  };\n\n  function CDOToken() {\n    return this;\n  }\n\n  CDOToken.prototype = Object.create(CSSParserToken.prototype);\n  CDOToken.prototype.tokenType = \"CDO\";\n\n  CDOToken.prototype.toSource = function () {\n    return \"<!--\";\n  };\n\n  function CDCToken() {\n    return this;\n  }\n\n  CDCToken.prototype = Object.create(CSSParserToken.prototype);\n  CDCToken.prototype.tokenType = \"CDC\";\n\n  CDCToken.prototype.toSource = function () {\n    return \"-->\";\n  };\n\n  function ColonToken() {\n    return this;\n  }\n\n  ColonToken.prototype = Object.create(CSSParserToken.prototype);\n  ColonToken.prototype.tokenType = \":\";\n\n  function SemicolonToken() {\n    return this;\n  }\n\n  SemicolonToken.prototype = Object.create(CSSParserToken.prototype);\n  SemicolonToken.prototype.tokenType = \";\";\n\n  function CommaToken() {\n    return this;\n  }\n\n  CommaToken.prototype = Object.create(CSSParserToken.prototype);\n  CommaToken.prototype.tokenType = \",\";\n\n  function GroupingToken() {\n    throw \"Abstract Base Class\";\n  }\n\n  GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n\n  function OpenCurlyToken() {\n    this.value = \"{\";\n    this.mirror = \"}\";\n    return this;\n  }\n\n  OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);\n  OpenCurlyToken.prototype.tokenType = \"{\";\n\n  function CloseCurlyToken() {\n    this.value = \"}\";\n    this.mirror = \"{\";\n    return this;\n  }\n\n  CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);\n  CloseCurlyToken.prototype.tokenType = \"}\";\n\n  function OpenSquareToken() {\n    this.value = \"[\";\n    this.mirror = \"]\";\n    return this;\n  }\n\n  OpenSquareToken.prototype = Object.create(GroupingToken.prototype);\n  OpenSquareToken.prototype.tokenType = \"[\";\n\n  function CloseSquareToken() {\n    this.value = \"]\";\n    this.mirror = \"[\";\n    return this;\n  }\n\n  CloseSquareToken.prototype = Object.create(GroupingToken.prototype);\n  CloseSquareToken.prototype.tokenType = \"]\";\n\n  function OpenParenToken() {\n    this.value = \"(\";\n    this.mirror = \")\";\n    return this;\n  }\n\n  OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n  OpenParenToken.prototype.tokenType = \"(\";\n\n  function CloseParenToken() {\n    this.value = \")\";\n    this.mirror = \"(\";\n    return this;\n  }\n\n  CloseParenToken.prototype = Object.create(GroupingToken.prototype);\n  CloseParenToken.prototype.tokenType = \")\";\n\n  function IncludeMatchToken() {\n    return this;\n  }\n\n  IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  IncludeMatchToken.prototype.tokenType = \"~=\";\n\n  function DashMatchToken() {\n    return this;\n  }\n\n  DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  DashMatchToken.prototype.tokenType = \"|=\";\n\n  function PrefixMatchToken() {\n    return this;\n  }\n\n  PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  PrefixMatchToken.prototype.tokenType = \"^=\";\n\n  function SuffixMatchToken() {\n    return this;\n  }\n\n  SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  SuffixMatchToken.prototype.tokenType = \"$=\";\n\n  function SubstringMatchToken() {\n    return this;\n  }\n\n  SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n  SubstringMatchToken.prototype.tokenType = \"*=\";\n\n  function ColumnToken() {\n    return this;\n  }\n\n  ColumnToken.prototype = Object.create(CSSParserToken.prototype);\n  ColumnToken.prototype.tokenType = \"||\";\n\n  function EOFToken() {\n    return this;\n  }\n\n  EOFToken.prototype = Object.create(CSSParserToken.prototype);\n  EOFToken.prototype.tokenType = \"EOF\";\n\n  EOFToken.prototype.toSource = function () {\n    return \"\";\n  };\n\n  function DelimToken(code) {\n    this.value = stringFromCode(code);\n    return this;\n  }\n\n  DelimToken.prototype = Object.create(CSSParserToken.prototype);\n  DelimToken.prototype.tokenType = \"DELIM\";\n\n  DelimToken.prototype.toString = function () {\n    return \"DELIM(\" + this.value + \")\";\n  };\n\n  DelimToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  };\n\n  DelimToken.prototype.toSource = function () {\n    if (this.value == \"\\\\\") return \"\\\\\\n\";else return this.value;\n  };\n\n  function StringValuedToken() {\n    throw \"Abstract Base Class\";\n  }\n\n  StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n\n  StringValuedToken.prototype.ASCIIMatch = function (str) {\n    return this.value.toLowerCase() == str.toLowerCase();\n  };\n\n  StringValuedToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  };\n\n  function IdentToken(val) {\n    this.value = val;\n  }\n\n  IdentToken.prototype = Object.create(StringValuedToken.prototype);\n  IdentToken.prototype.tokenType = \"IDENT\";\n\n  IdentToken.prototype.toString = function () {\n    return \"IDENT(\" + this.value + \")\";\n  };\n\n  IdentToken.prototype.toSource = function () {\n    return escapeIdent(this.value);\n  };\n\n  function FunctionToken(val) {\n    this.value = val;\n    this.mirror = \")\";\n  }\n\n  FunctionToken.prototype = Object.create(StringValuedToken.prototype);\n  FunctionToken.prototype.tokenType = \"FUNCTION\";\n\n  FunctionToken.prototype.toString = function () {\n    return \"FUNCTION(\" + this.value + \")\";\n  };\n\n  FunctionToken.prototype.toSource = function () {\n    return escapeIdent(this.value) + \"(\";\n  };\n\n  function AtKeywordToken(val) {\n    this.value = val;\n  }\n\n  AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);\n  AtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\n\n  AtKeywordToken.prototype.toString = function () {\n    return \"AT(\" + this.value + \")\";\n  };\n\n  AtKeywordToken.prototype.toSource = function () {\n    return \"@\" + escapeIdent(this.value);\n  };\n\n  function HashToken(val) {\n    this.value = val;\n    this.type = \"unrestricted\";\n  }\n\n  HashToken.prototype = Object.create(StringValuedToken.prototype);\n  HashToken.prototype.tokenType = \"HASH\";\n\n  HashToken.prototype.toString = function () {\n    return \"HASH(\" + this.value + \")\";\n  };\n\n  HashToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  };\n\n  HashToken.prototype.toSource = function () {\n    if (this.type == \"id\") {\n      return \"#\" + escapeIdent(this.value);\n    } else {\n      return \"#\" + escapeHash(this.value);\n    }\n  };\n\n  function StringToken(val) {\n    this.value = val;\n  }\n\n  StringToken.prototype = Object.create(StringValuedToken.prototype);\n  StringToken.prototype.tokenType = \"STRING\";\n\n  StringToken.prototype.toString = function () {\n    return '\"' + escapeString(this.value) + '\"';\n  };\n\n  function URLToken(val) {\n    this.value = val;\n  }\n\n  URLToken.prototype = Object.create(StringValuedToken.prototype);\n  URLToken.prototype.tokenType = \"URL\";\n\n  URLToken.prototype.toString = function () {\n    return \"URL(\" + this.value + \")\";\n  };\n\n  URLToken.prototype.toSource = function () {\n    return 'url(\"' + escapeString(this.value) + '\")';\n  };\n\n  function NumberToken() {\n    this.value = null;\n    this.type = \"integer\";\n    this.repr = \"\";\n  }\n\n  NumberToken.prototype = Object.create(CSSParserToken.prototype);\n  NumberToken.prototype.tokenType = \"NUMBER\";\n\n  NumberToken.prototype.toString = function () {\n    if (this.type == \"integer\") return \"INT(\" + this.value + \")\";\n    return \"NUMBER(\" + this.value + \")\";\n  };\n\n  NumberToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  };\n\n  NumberToken.prototype.toSource = function () {\n    return this.repr;\n  };\n\n  function PercentageToken() {\n    this.value = null;\n    this.repr = \"\";\n  }\n\n  PercentageToken.prototype = Object.create(CSSParserToken.prototype);\n  PercentageToken.prototype.tokenType = \"PERCENTAGE\";\n\n  PercentageToken.prototype.toString = function () {\n    return \"PERCENTAGE(\" + this.value + \")\";\n  };\n\n  PercentageToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  };\n\n  PercentageToken.prototype.toSource = function () {\n    return this.repr + \"%\";\n  };\n\n  function DimensionToken() {\n    this.value = null;\n    this.type = \"integer\";\n    this.repr = \"\";\n    this.unit = \"\";\n  }\n\n  DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n  DimensionToken.prototype.tokenType = \"DIMENSION\";\n\n  DimensionToken.prototype.toString = function () {\n    return \"DIM(\" + this.value + \",\" + this.unit + \")\";\n  };\n\n  DimensionToken.prototype.toJSON = function () {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  };\n\n  DimensionToken.prototype.toSource = function () {\n    var source = this.repr;\n    var unit = escapeIdent(this.unit);\n\n    if (unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n      // Unit is ambiguous with scinot\n      // Remove the leading \"e\", replace with escape.\n      unit = \"\\\\65 \" + unit.slice(1, unit.length);\n    }\n\n    return source + unit;\n  };\n\n  function escapeIdent(string) {\n    string = '' + string;\n    var result = '';\n    var firstcode = string.charCodeAt(0);\n\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i);\n\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n      }\n\n      if (between(code, 0x1, 0x1f) || code == 0x7f || i == 0 && between(code, 0x30, 0x39) || i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d) {\n        result += '\\\\' + code.toString(16) + ' ';\n      } else if (code >= 0x80 || code == 0x2d || code == 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) {\n        result += string[i];\n      } else {\n        result += '\\\\' + string[i];\n      }\n    }\n\n    return result;\n  }\n\n  function escapeHash(string) {\n    // Escapes the contents of \"unrestricted\"-type hash tokens.\n    // Won't preserve the ID-ness of \"id\"-type hash tokens;\n    // use escapeIdent() for that.\n    string = '' + string;\n    var result = '';\n    var firstcode = string.charCodeAt(0);\n\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i);\n\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n      }\n\n      if (code >= 0x80 || code == 0x2d || code == 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) {\n        result += string[i];\n      } else {\n        result += '\\\\' + code.toString(16) + ' ';\n      }\n    }\n\n    return result;\n  }\n\n  function escapeString(string) {\n    string = '' + string;\n    var result = '';\n\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i);\n\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n      }\n\n      if (between(code, 0x1, 0x1f) || code == 0x7f) {\n        result += '\\\\' + code.toString(16) + ' ';\n      } else if (code == 0x22 || code == 0x5c) {\n        result += '\\\\' + string[i];\n      } else {\n        result += string[i];\n      }\n    }\n\n    return result;\n  } // Exportation.\n\n\n  exports.tokenize = tokenize;\n  exports.IdentToken = IdentToken;\n  exports.FunctionToken = FunctionToken;\n  exports.AtKeywordToken = AtKeywordToken;\n  exports.HashToken = HashToken;\n  exports.StringToken = StringToken;\n  exports.BadStringToken = BadStringToken;\n  exports.URLToken = URLToken;\n  exports.BadURLToken = BadURLToken;\n  exports.DelimToken = DelimToken;\n  exports.NumberToken = NumberToken;\n  exports.PercentageToken = PercentageToken;\n  exports.DimensionToken = DimensionToken;\n  exports.IncludeMatchToken = IncludeMatchToken;\n  exports.DashMatchToken = DashMatchToken;\n  exports.PrefixMatchToken = PrefixMatchToken;\n  exports.SuffixMatchToken = SuffixMatchToken;\n  exports.SubstringMatchToken = SubstringMatchToken;\n  exports.ColumnToken = ColumnToken;\n  exports.WhitespaceToken = WhitespaceToken;\n  exports.CDOToken = CDOToken;\n  exports.CDCToken = CDCToken;\n  exports.ColonToken = ColonToken;\n  exports.SemicolonToken = SemicolonToken;\n  exports.CommaToken = CommaToken;\n  exports.OpenParenToken = OpenParenToken;\n  exports.CloseParenToken = CloseParenToken;\n  exports.OpenSquareToken = OpenSquareToken;\n  exports.CloseSquareToken = CloseSquareToken;\n  exports.OpenCurlyToken = OpenCurlyToken;\n  exports.CloseCurlyToken = CloseCurlyToken;\n  exports.EOFToken = EOFToken;\n  exports.CSSParserToken = CSSParserToken;\n  exports.GroupingToken = GroupingToken;\n});\n\n/***/ }),\n\n/***/ \"./src/server/common/selectorParser.ts\":\n/*!*********************************************!*\\\n  !*** ./src/server/common/selectorParser.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseSelector = parseSelector;\nexports.customCSSNames = void 0;\n\nvar _cssParser = __webpack_require__(/*! ./cssParser */ \"./src/server/common/cssParser.ts\");\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);\nexports.customCSSNames = customCSSNames;\n\nfunction parseSelector(selector) {\n  const result = parseSelectorV1(selector);\n  result.parts = result.parts.map(part => {\n    if (Array.isArray(part)) return part;\n\n    if (part.name === 'css' || part.name === 'css:light') {\n      if (part.name === 'css:light') part.body = ':light(' + part.body + ')';\n      const parsedCSS = (0, _cssParser.parseCSS)(part.body, customCSSNames);\n      return parsedCSS.selector;\n    }\n\n    return part;\n  });\n  return {\n    parts: result.parts,\n    capture: result.capture\n  };\n}\n\nfunction parseSelectorV1(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = {\n    parts: []\n  };\n\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf('=');\n    let name;\n    let body;\n\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n      name = 'text';\n      body = part;\n    } else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n      name = 'text';\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {\n      // If selector starts with '//' or '//' prefixed with multiple opening\n      // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817\n      // If selector starts with '..', consider xpath as well.\n      name = 'xpath';\n      body = part;\n    } else {\n      name = 'css';\n      body = part;\n    }\n\n    let capture = false;\n\n    if (name[0] === '*') {\n      capture = true;\n      name = name.substring(1);\n    }\n\n    result.parts.push({\n      name,\n      body\n    });\n\n    if (capture) {\n      if (result.capture !== undefined) throw new Error(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n\n  if (!selector.includes('>>')) {\n    index = selector.length;\n    append();\n    return result;\n  }\n\n  while (index < selector.length) {\n    const c = selector[index];\n\n    if (c === '\\\\' && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = undefined;\n      index++;\n    } else if (!quote && (c === '\"' || c === '\\'' || c === '`')) {\n      quote = c;\n      index++;\n    } else if (!quote && c === '>' && selector[index + 1] === '>') {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n\n  append();\n  return result;\n}\n\n/***/ }),\n\n/***/ \"./src/server/injected/selectorEvaluator.ts\":\n/*!**************************************************!*\\\n  !*** ./src/server/injected/selectorEvaluator.ts ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLaxTextMatcher = createLaxTextMatcher;\nexports.createStrictTextMatcher = createStrictTextMatcher;\nexports.createRegexTextMatcher = createRegexTextMatcher;\nexports.elementText = elementText;\nexports.elementMatchesText = elementMatchesText;\nexports.parentElementOrShadowHost = parentElementOrShadowHost;\nexports.isVisible = isVisible;\nexports.SelectorEvaluatorImpl = void 0;\n\nvar _selectorParser = __webpack_require__(/*! ../common/selectorParser */ \"./src/server/common/selectorParser.ts\");\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass SelectorEvaluatorImpl {\n  constructor(extraEngines) {\n    this._engines = new Map();\n    this._cacheQueryCSS = new Map();\n    this._cacheMatches = new Map();\n    this._cacheQuery = new Map();\n    this._cacheMatchesSimple = new Map();\n    this._cacheMatchesParents = new Map();\n    this._cacheCallMatches = new Map();\n    this._cacheCallQuery = new Map();\n    this._cacheQuerySimple = new Map();\n    this._cacheText = new Map();\n    this._scoreMap = void 0;\n    this._retainCacheCounter = 0;\n\n    for (const [name, engine] of extraEngines) this._engines.set(name, engine);\n\n    this._engines.set('not', notEngine);\n\n    this._engines.set('is', isEngine);\n\n    this._engines.set('where', isEngine);\n\n    this._engines.set('has', hasEngine);\n\n    this._engines.set('scope', scopeEngine);\n\n    this._engines.set('light', lightEngine);\n\n    this._engines.set('visible', visibleEngine);\n\n    this._engines.set('text', textEngine);\n\n    this._engines.set('text-is', textIsEngine);\n\n    this._engines.set('text-matches', textMatchesEngine);\n\n    this._engines.set('has-text', hasTextEngine);\n\n    this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));\n\n    this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));\n\n    this._engines.set('above', createPositionEngine('above', boxAbove));\n\n    this._engines.set('below', createPositionEngine('below', boxBelow));\n\n    this._engines.set('near', createPositionEngine('near', boxNear));\n\n    this._engines.set('nth-match', nthMatchEngine);\n\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [..._selectorParser.customCSSNames];\n    parserNames.sort();\n    if (allNames.join('|') !== parserNames.join('|')) throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join('|')} vs ${parserNames.join('|')}`);\n  }\n\n  begin() {\n    ++this._retainCacheCounter;\n  }\n\n  end() {\n    --this._retainCacheCounter;\n\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n\n      this._cacheMatches.clear();\n\n      this._cacheQuery.clear();\n\n      this._cacheMatchesSimple.clear();\n\n      this._cacheMatchesParents.clear();\n\n      this._cacheCallMatches.clear();\n\n      this._cacheCallQuery.clear();\n\n      this._cacheQuerySimple.clear();\n\n      this._cacheText.clear();\n    }\n  }\n\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main)) cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));\n    if (entry) return entry.result;\n    const result = cb();\n    entries.push({\n      rest,\n      result\n    });\n    return result;\n  }\n\n  _checkSelector(s) {\n    const wellFormed = typeof s === 'object' && s && (Array.isArray(s) || 'simples' in s && s.simples.length);\n    if (!wellFormed) throw new Error(`Malformed selector \"${s}\"`);\n    return s;\n  }\n\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n\n    this.begin();\n\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\n        if (Array.isArray(selector)) return this._matchesEngine(isEngine, element, selector, context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context)) return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n\n  query(context, s) {\n    const selector = this._checkSelector(s);\n\n    this.begin();\n\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\n        if (Array.isArray(selector)) return this._queryEngine(isEngine, context, selector); // query() recursively calls itself, so we set up a new map for this particular query() call.\n\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = new Map();\n\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n\n        elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));\n\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n\n            const bScore = this._scoreMap.get(b);\n\n            if (aScore === bScore) return 0;\n            if (aScore === undefined) return 1;\n            if (bScore === undefined) return -1;\n            return aScore - bScore;\n          });\n        }\n\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n\n  _markScore(element, score) {\n    // HACK ALERT: temporary marks an element with a score, to be used\n    // for sorting at the end of the query().\n    if (this._scoreMap) this._scoreMap.set(element, score);\n  }\n\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\n      const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');\n      if (!isPossiblyScopeClause && element === context.scope) return false;\n      if (simple.css && !this._matchesCSS(element, simple.css)) return false;\n\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context)) return false;\n      }\n\n      return true;\n    });\n  }\n\n  _querySimple(context, simple) {\n    if (!simple.functions.length) return this._queryCSS(context, simple.css || '*');\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\n      let css = simple.css;\n      const funcs = simple.functions;\n      if (css === '*' && funcs.length) css = undefined;\n      let elements;\n      let firstIndex = -1;\n\n      if (css !== undefined) {\n        elements = this._queryCSS(context, css);\n      } else {\n        firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);\n        if (firstIndex === -1) firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex) continue;\n\n        const engine = this._getEngine(funcs[i].name);\n\n        if (engine.matches !== undefined) elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex) continue;\n\n        const engine = this._getEngine(funcs[i].name);\n\n        if (engine.matches === undefined) elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n\n      return elements;\n    });\n  }\n\n  _matchesParents(element, complex, index, context) {\n    if (index < 0) return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\n      const {\n        selector: simple,\n        combinator\n      } = complex.simples[index];\n\n      if (combinator === '>') {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context)) return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n\n      if (combinator === '+') {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context)) return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n\n      if (combinator === '') {\n        let parent = parentElementOrShadowHostInContext(element, context);\n\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context)) return true;\n            if (complex.simples[index - 1].combinator === '') break;\n          }\n\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n\n        return false;\n      }\n\n      if (combinator === '~') {\n        let previousSibling = previousSiblingInContext(element, context);\n\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context)) return true;\n            if (complex.simples[index - 1].combinator === '~') break;\n          }\n\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n\n        return false;\n      }\n\n      if (combinator === '>=') {\n        let parent = element;\n\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context)) return true;\n            if (complex.simples[index - 1].combinator === '') break;\n          }\n\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n\n        return false;\n      }\n\n      throw new Error(`Unsupported combinator \"${combinator}\"`);\n    });\n  }\n\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches) return this._callMatches(engine, element, args, context);\n    if (engine.query) return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n  }\n\n  _queryEngine(engine, context, args) {\n    if (engine.query) return this._callQuery(engine, args, context);\n    if (engine.matches) return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n  }\n\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n\n  _matchesCSS(element, css) {\n    return element.matches(css);\n  }\n\n  _queryCSS(context, css) {\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {\n      let result = [];\n\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css)]);\n        if (!context.pierceShadow) return;\n        if (root.shadowRoot) query(root.shadowRoot);\n\n        for (const element of root.querySelectorAll('*')) {\n          if (element.shadowRoot) query(element.shadowRoot);\n        }\n      }\n\n      query(context.scope);\n      return result;\n    });\n  }\n\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n\n    if (!engine) throw new Error(`Unknown selector engine \"${name}\"`);\n    return engine;\n  }\n\n}\n\nexports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;\nconst isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0) throw new Error(`\"is\" engine expects non-empty selector list`);\n    return args.some(selector => evaluator.matches(element, selector, context));\n  },\n\n  query(context, args, evaluator) {\n    if (args.length === 0) throw new Error(`\"is\" engine expects non-empty selector list`);\n    let elements = [];\n\n    for (const arg of args) elements = elements.concat(evaluator.query(context, arg));\n\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n\n};\nconst hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0) throw new Error(`\"has\" engine expects non-empty selector list`);\n    return evaluator.query({ ...context,\n      scope: element\n    }, args).length > 0;\n  } // TODO: we do not implement \"relative selectors\", as in \"div:has(> span)\" or \"div:has(+ span)\".\n  // TODO: we can implement efficient \"query\" by matching \"args\" and returning\n  // all parents/descendants, just have to be careful with the \":scope\" matching.\n\n\n};\nconst scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0) throw new Error(`\"scope\" engine expects no arguments`);\n    if (context.scope.nodeType === 9\n    /* Node.DOCUMENT_NODE */\n    ) return element === context.scope.documentElement;\n    return element === context.scope;\n  },\n\n  query(context, args, evaluator) {\n    if (args.length !== 0) throw new Error(`\"scope\" engine expects no arguments`);\n\n    if (context.scope.nodeType === 9\n    /* Node.DOCUMENT_NODE */\n    ) {\n        const root = context.scope.documentElement;\n        return root ? [root] : [];\n      }\n\n    if (context.scope.nodeType === 1\n    /* Node.ELEMENT_NODE */\n    ) return [context.scope];\n    return [];\n  }\n\n};\nconst notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0) throw new Error(`\"not\" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n\n};\nconst lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context,\n      pierceShadow: false\n    }, args);\n  },\n\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context,\n      pierceShadow: false\n    });\n  }\n\n};\nconst visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length) throw new Error(`\"visible\" engine expects no arguments`);\n    return isVisible(element);\n  }\n\n};\nconst textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== 'string') throw new Error(`\"text\" engine expects a single string`);\n    const matcher = createLaxTextMatcher(args[0]);\n    return elementMatchesText(evaluator, element, matcher) === 'self';\n  }\n\n};\nconst textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== 'string') throw new Error(`\"text-is\" engine expects a single string`);\n    const matcher = createStrictTextMatcher(args[0]);\n    return elementMatchesText(evaluator, element, matcher) !== 'none';\n  }\n\n};\nconst textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || args.length === 2 && typeof args[1] !== 'string') throw new Error(`\"text-matches\" engine expects a regexp body and optional regexp flags`);\n    const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);\n    return elementMatchesText(evaluator, element, matcher) === 'self';\n  }\n\n};\nconst hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== 'string') throw new Error(`\"has-text\" engine expects a single string`);\n    if (shouldSkipForTextMatching(element)) return false;\n    const matcher = createLaxTextMatcher(args[0]);\n    return matcher(elementText(evaluator, element));\n  }\n\n};\n\nfunction createLaxTextMatcher(text) {\n  text = text.trim().replace(/\\s+/g, ' ').toLowerCase();\n  return elementText => {\n    const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();\n    return s.includes(text);\n  };\n}\n\nfunction createStrictTextMatcher(text) {\n  text = text.trim().replace(/\\s+/g, ' ');\n  return elementText => {\n    return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);\n  };\n}\n\nfunction createRegexTextMatcher(source, flags) {\n  const re = new RegExp(source, flags);\n  return elementText => {\n    return re.test(elementText.full);\n  };\n}\n\nfunction shouldSkipForTextMatching(element) {\n  return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);\n}\n\nfunction elementText(evaluator, root) {\n  let value = evaluator._cacheText.get(root);\n\n  if (value === undefined) {\n    value = {\n      full: '',\n      immediate: []\n    };\n\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = '';\n\n      if (root instanceof HTMLInputElement && (root.type === 'submit' || root.type === 'button')) {\n        value = {\n          full: root.value,\n          immediate: [root.value]\n        };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || '';\n            currentImmediate += child.nodeValue || '';\n          } else {\n            if (currentImmediate) value.immediate.push(currentImmediate);\n            currentImmediate = '';\n            if (child.nodeType === Node.ELEMENT_NODE) value.full += elementText(evaluator, child).full;\n          }\n        }\n\n        if (currentImmediate) value.immediate.push(currentImmediate);\n        if (root.shadowRoot) value.full += elementText(evaluator, root.shadowRoot).full;\n      }\n    }\n\n    evaluator._cacheText.set(root, value);\n  }\n\n  return value;\n}\n\nfunction elementMatchesText(evaluator, element, matcher) {\n  if (shouldSkipForTextMatching(element)) return 'none';\n  if (!matcher(elementText(evaluator, element))) return 'none';\n\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child))) return 'selfAndChildren';\n  }\n\n  if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot))) return 'selfAndChildren';\n  return 'self';\n}\n\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== undefined && distance > maxDistance) return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\n\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== undefined && distance > maxDistance) return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\n\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== undefined && distance > maxDistance) return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\n\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== undefined && distance > maxDistance) return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\n\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === undefined ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0) score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0) score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0) score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0) score += box1.top - box2.bottom;\n  return score > kThreshold ? undefined : score;\n}\n\nfunction createPositionEngine(name, scorer) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;\n      const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === undefined ? 0 : 1)) throw new Error(`\"${name}\" engine expects a selector list and optional maximum distance in pixels`);\n      const box = element.getBoundingClientRect();\n      let bestScore;\n\n      for (const e of evaluator.query(context, queryArgs)) {\n        if (e === element) continue;\n        const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n        if (score === undefined) continue;\n        if (bestScore === undefined || score < bestScore) bestScore = score;\n      }\n\n      if (bestScore === undefined) return false;\n\n      evaluator._markScore(element, bestScore);\n\n      return true;\n    }\n\n  };\n}\n\nconst nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2) throw new Error(`\"nth-match\" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== 'number' || index < 1) throw new Error(`\"nth-match\" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--; // one-based\n\n    return index < elements.length ? [elements[index]] : [];\n  }\n\n};\n\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement) return element.parentElement;\n  if (!element.parentNode) return;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host) return element.parentNode.host;\n}\n\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope) return;\n  if (!context.pierceShadow) return element.parentElement || undefined;\n  return parentElementOrShadowHost(element);\n}\n\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope) return;\n  return element.previousElementSibling || undefined;\n}\n\nfunction isVisible(element) {\n  // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.\n  if (!element.ownerDocument || !element.ownerDocument.defaultView) return true;\n  const style = element.ownerDocument.defaultView.getComputedStyle(element);\n  if (!style || style.visibility === 'hidden') return false;\n  const rect = element.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\n\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = new Map();\n  const roots = [];\n  const result = [];\n\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry) return entry;\n    const parent = parentElementOrShadowHost(element);\n\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n\n    entry = {\n      children: [],\n      taken: false\n    };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n\n  elements.forEach(e => append(e).taken = true);\n\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken) result.push(element);\n\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n\n      while (child && entry.children.length < set.size) {\n        if (set.has(child)) entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n\n      while (child && entry.children.length < set.size) {\n        if (set.has(child)) entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n\n    entry.children.forEach(visit);\n  }\n\n  roots.forEach(visit);\n  return result;\n}\n\n/***/ }),\n\n/***/ \"./src/server/supplements/injected/recorder.ts\":\n/*!*****************************************************!*\\\n  !*** ./src/server/supplements/injected/recorder.ts ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Recorder = void 0;\n\nvar _selectorGenerator = __webpack_require__(/*! ./selectorGenerator */ \"./src/server/supplements/injected/selectorGenerator.ts\");\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst scriptSymbol = Symbol('scriptSymbol');\n\nclass Recorder {\n  constructor(injectedScript, params) {\n    this._injectedScript = void 0;\n    this._performingAction = false;\n    this._outerGlassPaneElement = void 0;\n    this._glassPaneShadow = void 0;\n    this._innerGlassPaneElement = void 0;\n    this._highlightElements = [];\n    this._tooltipElement = void 0;\n    this._listeners = [];\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._activeModel = null;\n    this._expectProgrammaticKeyUp = false;\n    this._pollRecorderModeTimer = void 0;\n    this._mode = 'none';\n    this._actionPointElement = void 0;\n    this._actionPoint = void 0;\n    this._actionSelector = void 0;\n    this._params = void 0;\n    this._params = params;\n    this._injectedScript = injectedScript;\n    this._outerGlassPaneElement = document.createElement('x-pw-glass');\n    this._outerGlassPaneElement.style.position = 'fixed';\n    this._outerGlassPaneElement.style.top = '0';\n    this._outerGlassPaneElement.style.right = '0';\n    this._outerGlassPaneElement.style.bottom = '0';\n    this._outerGlassPaneElement.style.left = '0';\n    this._outerGlassPaneElement.style.zIndex = '2147483647';\n    this._outerGlassPaneElement.style.pointerEvents = 'none';\n    this._outerGlassPaneElement.style.display = 'flex';\n    this._tooltipElement = document.createElement('x-pw-tooltip');\n    this._actionPointElement = document.createElement('x-pw-action-point');\n\n    this._actionPointElement.setAttribute('hidden', 'true');\n\n    this._innerGlassPaneElement = document.createElement('x-pw-glass-inner');\n    this._innerGlassPaneElement.style.flex = 'auto';\n\n    this._innerGlassPaneElement.appendChild(this._tooltipElement); // Use a closed shadow root to prevent selectors matching our internal previews.\n\n\n    this._glassPaneShadow = this._outerGlassPaneElement.attachShadow({\n      mode: this._params.isUnderTest ? 'open' : 'closed'\n    });\n\n    this._glassPaneShadow.appendChild(this._innerGlassPaneElement);\n\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n\n    const styleElement = document.createElement('style');\n    styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',\n                       'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n\n    this._glassPaneShadow.appendChild(styleElement);\n\n    this._refreshListenersIfNeeded();\n\n    setInterval(() => {\n      this._refreshListenersIfNeeded();\n\n      if (params.isUnderTest && !this._reportedReadyForTest) {\n        this._reportedReadyForTest = true;\n        console.error('Recorder script ready for test');\n      }\n    }, 500);\n\n    globalThis._playwrightRefreshOverlay = () => {\n      this._pollRecorderMode().catch(e => console.log(e)); // eslint-disable-line no-console\n\n    };\n\n    globalThis._playwrightRefreshOverlay();\n  }\n\n  _refreshListenersIfNeeded() {\n    if (document.documentElement[scriptSymbol]) return;\n    document.documentElement[scriptSymbol] = true;\n    removeEventListeners(this._listeners);\n    this._listeners = [addEventListener(document, 'click', event => this._onClick(event), true), addEventListener(document, 'auxclick', event => this._onClick(event), true), addEventListener(document, 'input', event => this._onInput(event), true), addEventListener(document, 'keydown', event => this._onKeyDown(event), true), addEventListener(document, 'keyup', event => this._onKeyUp(event), true), addEventListener(document, 'mousedown', event => this._onMouseDown(event), true), addEventListener(document, 'mouseup', event => this._onMouseUp(event), true), addEventListener(document, 'mousemove', event => this._onMouseMove(event), true), addEventListener(document, 'mouseleave', event => this._onMouseLeave(event), true), addEventListener(document, 'focus', () => this._onFocus(), true), addEventListener(document, 'scroll', () => {\n      this._hoveredModel = null;\n      this._actionPointElement.hidden = true;\n\n      this._updateHighlight();\n    }, true)];\n    document.documentElement.appendChild(this._outerGlassPaneElement);\n  }\n\n  async _pollRecorderMode() {\n    var _this$_hoveredModel;\n\n    const pollPeriod = 1000;\n    if (this._pollRecorderModeTimer) clearTimeout(this._pollRecorderModeTimer);\n    const state = await globalThis._playwrightRecorderState().catch(e => null);\n\n    if (!state) {\n      this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n      return;\n    }\n\n    const {\n      mode,\n      actionPoint,\n      actionSelector\n    } = state;\n\n    if (mode !== this._mode) {\n      this._mode = mode;\n\n      this._clearHighlight();\n    }\n\n    if (actionPoint && this._actionPoint && actionPoint.x === this._actionPoint.x && actionPoint.y === this._actionPoint.y) {// All good.\n    } else if (!actionPoint && !this._actionPoint) {// All good.\n    } else {\n      if (actionPoint) {\n        this._actionPointElement.style.top = actionPoint.y + 'px';\n        this._actionPointElement.style.left = actionPoint.x + 'px';\n        this._actionPointElement.hidden = false;\n      } else {\n        this._actionPointElement.hidden = true;\n      }\n\n      this._actionPoint = actionPoint;\n    } // Race or scroll.\n\n\n    if (this._actionSelector && !((_this$_hoveredModel = this._hoveredModel) !== null && _this$_hoveredModel !== void 0 && _this$_hoveredModel.elements.length)) this._actionSelector = undefined;\n\n    if (actionSelector !== this._actionSelector) {\n      this._hoveredModel = actionSelector ? (0, _selectorGenerator.querySelector)(this._injectedScript, actionSelector, document) : null;\n\n      this._updateHighlight();\n\n      this._actionSelector = actionSelector;\n    }\n\n    this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n  }\n\n  _clearHighlight() {\n    this._hoveredModel = null;\n    this._activeModel = null;\n\n    this._updateHighlight();\n  }\n\n  _actionInProgress(event) {\n    // If Playwright is performing action for us, bail.\n    if (this._performingAction) return true; // Consume as the first thing.\n\n    consumeEvent(event);\n    return false;\n  }\n\n  _consumedDueToNoModel(event, model) {\n    if (model) return false;\n    consumeEvent(event);\n    return true;\n  }\n\n  _consumedDueWrongTarget(event) {\n    if (this._activeModel && this._activeModel.elements[0] === this._deepEventTarget(event)) return false;\n    consumeEvent(event);\n    return true;\n  }\n\n  _onClick(event) {\n    if (this._mode === 'inspecting') globalThis._playwrightRecorderSetSelector(this._hoveredModel ? this._hoveredModel.selector : '');\n    if (this._shouldIgnoreMouseEvent(event)) return;\n    if (this._actionInProgress(event)) return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel)) return;\n    const checkbox = asCheckbox(this._deepEventTarget(event));\n\n    if (checkbox) {\n      // Interestingly, inputElement.checked is reversed inside this event handler.\n      this._performAction({\n        name: checkbox.checked ? 'check' : 'uncheck',\n        selector: this._hoveredModel.selector,\n        signals: []\n      });\n\n      return;\n    }\n\n    this._performAction({\n      name: 'click',\n      selector: this._hoveredModel.selector,\n      signals: [],\n      button: buttonForEvent(event),\n      modifiers: modifiersForEvent(event),\n      clickCount: event.detail\n    });\n  }\n\n  _shouldIgnoreMouseEvent(event) {\n    const target = this._deepEventTarget(event);\n\n    if (this._mode === 'none') return true;\n\n    if (this._mode === 'inspecting') {\n      consumeEvent(event);\n      return true;\n    }\n\n    const nodeName = target.nodeName;\n    if (nodeName === 'SELECT') return true;\n    if (nodeName === 'INPUT' && ['date'].includes(target.type)) return true;\n    return false;\n  }\n\n  _onMouseDown(event) {\n    if (this._shouldIgnoreMouseEvent(event)) return;\n    if (!this._performingAction) consumeEvent(event);\n    this._activeModel = this._hoveredModel;\n  }\n\n  _onMouseUp(event) {\n    if (this._shouldIgnoreMouseEvent(event)) return;\n    if (!this._performingAction) consumeEvent(event);\n  }\n\n  _onMouseMove(event) {\n    if (this._mode === 'none') return;\n\n    const target = this._deepEventTarget(event);\n\n    if (this._hoveredElement === target) return;\n    this._hoveredElement = target;\n\n    this._updateModelForHoveredElement();\n  }\n\n  _onMouseLeave(event) {\n    // Leaving iframe.\n    if (this._deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n      this._hoveredElement = null;\n\n      this._updateModelForHoveredElement();\n    }\n  }\n\n  _onFocus() {\n    const activeElement = this._deepActiveElement(document);\n\n    const result = activeElement ? (0, _selectorGenerator.generateSelector)(this._injectedScript, activeElement) : null;\n    this._activeModel = result && result.selector ? result : null;\n    if (this._params.isUnderTest) console.error('Highlight updated for test: ' + (result ? result.selector : null));\n  }\n\n  _updateModelForHoveredElement() {\n    if (!this._hoveredElement) {\n      this._hoveredModel = null;\n\n      this._updateHighlight();\n\n      return;\n    }\n\n    const hoveredElement = this._hoveredElement;\n    const {\n      selector,\n      elements\n    } = (0, _selectorGenerator.generateSelector)(this._injectedScript, hoveredElement);\n    if (this._hoveredModel && this._hoveredModel.selector === selector || this._hoveredElement !== hoveredElement) return;\n    this._hoveredModel = selector ? {\n      selector,\n      elements\n    } : null;\n\n    this._updateHighlight();\n\n    if (this._params.isUnderTest) console.error('Highlight updated for test: ' + selector);\n  }\n\n  _updateHighlight() {\n    const elements = this._hoveredModel ? this._hoveredModel.elements : []; // Code below should trigger one layout and leave with the\n    // destroyed layout.\n    // Destroy the layout\n\n    this._tooltipElement.textContent = this._hoveredModel ? this._hoveredModel.selector : '';\n    this._tooltipElement.style.top = '0';\n    this._tooltipElement.style.left = '0';\n    this._tooltipElement.style.display = 'flex'; // Trigger layout.\n\n    const boxes = elements.map(e => e.getBoundingClientRect());\n    const tooltipWidth = this._tooltipElement.offsetWidth;\n    const tooltipHeight = this._tooltipElement.offsetHeight;\n    const totalWidth = this._innerGlassPaneElement.offsetWidth;\n    const totalHeight = this._innerGlassPaneElement.offsetHeight; // Destroy the layout again.\n\n    if (boxes.length) {\n      const primaryBox = boxes[0];\n      let anchorLeft = primaryBox.left;\n      if (anchorLeft + tooltipWidth > totalWidth - 5) anchorLeft = totalWidth - tooltipWidth - 5;\n      let anchorTop = primaryBox.bottom + 5;\n\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\n        // If can't fit below, either position above...\n        if (primaryBox.top > tooltipHeight + 5) {\n          anchorTop = primaryBox.top - tooltipHeight - 5;\n        } else {\n          // Or on top in case of large element\n          anchorTop = totalHeight - 5 - tooltipHeight;\n        }\n      }\n\n      this._tooltipElement.style.top = anchorTop + 'px';\n      this._tooltipElement.style.left = anchorLeft + 'px';\n    } else {\n      this._tooltipElement.style.display = 'none';\n    }\n\n    const pool = this._highlightElements;\n    this._highlightElements = [];\n\n    for (const box of boxes) {\n      const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();\n      const color = this._mode === 'recording' ? '#dc6f6f7f' : '#6fa8dc7f';\n      highlightElement.style.backgroundColor = this._highlightElements.length ? '#f6b26b7f' : color;\n      highlightElement.style.left = box.x + 'px';\n      highlightElement.style.top = box.y + 'px';\n      highlightElement.style.width = box.width + 'px';\n      highlightElement.style.height = box.height + 'px';\n      highlightElement.style.display = 'block';\n\n      this._highlightElements.push(highlightElement);\n    }\n\n    for (const highlightElement of pool) {\n      highlightElement.style.display = 'none';\n\n      this._highlightElements.push(highlightElement);\n    }\n  }\n\n  _createHighlightElement() {\n    const highlightElement = document.createElement('x-pw-highlight');\n    highlightElement.style.position = 'absolute';\n    highlightElement.style.top = '0';\n    highlightElement.style.left = '0';\n    highlightElement.style.width = '0';\n    highlightElement.style.height = '0';\n    highlightElement.style.boxSizing = 'border-box';\n\n    this._glassPaneShadow.appendChild(highlightElement);\n\n    return highlightElement;\n  }\n\n  _onInput(event) {\n    if (this._mode !== 'recording') return true;\n\n    const target = this._deepEventTarget(event);\n\n    if (['INPUT', 'TEXTAREA'].includes(target.nodeName)) {\n      const inputElement = target;\n      const elementType = (inputElement.type || '').toLowerCase();\n\n      if (elementType === 'checkbox') {\n        // Checkbox is handled in click, we can't let input trigger on checkbox - that would mean we dispatched click events while recording.\n        return;\n      }\n\n      if (elementType === 'file') {\n        globalThis._playwrightRecorderRecordAction({\n          name: 'setInputFiles',\n          selector: this._activeModel.selector,\n          signals: [],\n          files: [...(inputElement.files || [])].map(file => file.name)\n        });\n\n        return;\n      } // Non-navigating actions are simply recorded by Playwright.\n\n\n      if (this._consumedDueWrongTarget(event)) return;\n\n      globalThis._playwrightRecorderRecordAction({\n        name: 'fill',\n        selector: this._activeModel.selector,\n        signals: [],\n        text: inputElement.value\n      });\n    }\n\n    if (target.nodeName === 'SELECT') {\n      const selectElement = target;\n      if (this._actionInProgress(event)) return;\n\n      this._performAction({\n        name: 'select',\n        selector: this._hoveredModel.selector,\n        options: [...selectElement.selectedOptions].map(option => option.value),\n        signals: []\n      });\n    }\n  }\n\n  _shouldGenerateKeyPressFor(event) {\n    // Backspace, Delete, AltGraph are changing input, will handle it there.\n    if (['Backspace', 'Delete', 'AltGraph'].includes(event.key)) return false; // Ignore the QWERTZ shortcut for creating a at sign on MacOS\n\n    if (event.key === '@' && event.code === 'KeyL') return false; // Allow and ignore common used shortcut for pasting.\n\n    if (navigator.platform.includes('Mac')) {\n      if (event.key === 'v' && event.metaKey) return false;\n    } else {\n      if (event.key === 'v' && event.ctrlKey) return false;\n      if (event.key === 'Insert' && event.shiftKey) return false;\n    }\n\n    if (['Shift', 'Control', 'Meta', 'Alt'].includes(event.key)) return false;\n    const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n    if (event.key.length === 1 && !hasModifier) return !!asCheckbox(this._deepEventTarget(event));\n    return true;\n  }\n\n  _onKeyDown(event) {\n    if (this._mode === 'inspecting') {\n      consumeEvent(event);\n      return;\n    }\n\n    if (this._mode !== 'recording') return true;\n    if (!this._shouldGenerateKeyPressFor(event)) return;\n\n    if (this._actionInProgress(event)) {\n      this._expectProgrammaticKeyUp = true;\n      return;\n    }\n\n    if (this._consumedDueWrongTarget(event)) return; // Similarly to click, trigger checkbox on key event, not input.\n\n    if (event.key === ' ') {\n      const checkbox = asCheckbox(this._deepEventTarget(event));\n\n      if (checkbox) {\n        this._performAction({\n          name: checkbox.checked ? 'uncheck' : 'check',\n          selector: this._activeModel.selector,\n          signals: []\n        });\n\n        return;\n      }\n    }\n\n    this._performAction({\n      name: 'press',\n      selector: this._activeModel.selector,\n      signals: [],\n      key: event.key,\n      modifiers: modifiersForEvent(event)\n    });\n  }\n\n  _onKeyUp(event) {\n    if (!this._shouldGenerateKeyPressFor(event)) return; // Only allow programmatic keyups, ignore user input.\n\n    if (!this._expectProgrammaticKeyUp) {\n      consumeEvent(event);\n      return;\n    }\n\n    this._expectProgrammaticKeyUp = false;\n  }\n\n  async _performAction(action) {\n    this._performingAction = true;\n    await globalThis._playwrightRecorderPerformAction(action).catch(() => {});\n    this._performingAction = false; // Action could have changed DOM, update hovered model selectors.\n\n    this._updateModelForHoveredElement(); // If that was a keyboard action, it similarly requires new selectors for active model.\n\n\n    this._onFocus();\n\n    if (this._params.isUnderTest) {\n      // Serialize all to string as we cannot attribute console message to isolated world\n      // in Firefox.\n      console.error('Action performed for test: ' + JSON.stringify({\n        hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n        active: this._activeModel ? this._activeModel.selector : null\n      }));\n    }\n  }\n\n  _deepEventTarget(event) {\n    return event.composedPath()[0];\n  }\n\n  _deepActiveElement(document) {\n    let activeElement = document.activeElement;\n\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) activeElement = activeElement.shadowRoot.activeElement;\n\n    return activeElement;\n  }\n\n}\n\nexports.Recorder = Recorder;\n\nfunction modifiersForEvent(event) {\n  return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\n\nfunction buttonForEvent(event) {\n  switch (event.which) {\n    case 1:\n      return 'left';\n\n    case 2:\n      return 'middle';\n\n    case 3:\n      return 'right';\n  }\n\n  return 'left';\n}\n\nfunction consumeEvent(e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.stopImmediatePropagation();\n}\n\nfunction asCheckbox(node) {\n  if (!node || node.nodeName !== 'INPUT') return null;\n  const inputElement = node;\n  return inputElement.type === 'checkbox' ? inputElement : null;\n}\n\nfunction addEventListener(target, eventName, listener, useCapture) {\n  target.addEventListener(eventName, listener, useCapture);\n\n  const remove = () => {\n    target.removeEventListener(eventName, listener, useCapture);\n  };\n\n  return remove;\n}\n\nfunction removeEventListeners(listeners) {\n  for (const listener of listeners) listener();\n\n  listeners.splice(0, listeners.length);\n}\n\nvar _default = Recorder;\nexports.default = _default;\n\n/***/ }),\n\n/***/ \"./src/server/supplements/injected/selectorGenerator.ts\":\n/*!**************************************************************!*\\\n  !*** ./src/server/supplements/injected/selectorGenerator.ts ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.querySelector = querySelector;\nexports.generateSelector = generateSelector;\n\nvar _selectorEvaluator = __webpack_require__(/*! ../../injected/selectorEvaluator */ \"./src/server/injected/selectorEvaluator.ts\");\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst cacheAllowText = new Map();\nconst cacheDisallowText = new Map();\n\nfunction querySelector(injectedScript, selector, ownerDocument) {\n  try {\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)\n    };\n  } catch (e) {\n    return {\n      selector,\n      elements: []\n    };\n  }\n}\n\nfunction generateSelector(injectedScript, targetElement) {\n  injectedScript._evaluator.begin();\n\n  try {\n    targetElement = targetElement.closest('button,select,input,[role=button],[role=checkbox],[role=radio]') || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement);\n    const bestTokens = targetTokens || [cssFallback(injectedScript, targetElement)];\n    const selector = joinTokens(bestTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n\n    injectedScript._evaluator.end();\n  }\n}\n\nfunction filterRegexTokens(textCandidates) {\n  // Filter out regex-based selectors for better performance.\n  return textCandidates.filter(c => c[0].selector[0] !== '/');\n}\n\nfunction generateSelectorFor(injectedScript, targetElement) {\n  if (targetElement.ownerDocument.documentElement === targetElement) return [{\n    engine: 'css',\n    selector: 'html',\n    score: 1\n  }];\n\n  const calculate = (element, allowText) => {\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map(token => [token]) : [];\n\n    if (element !== targetElement) {\n      // Do not use regex for parent elements (for performance).\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n\n    const noTextCandidates = buildCandidates(injectedScript, element).map(token => [token]); // First check all text and non-text candidates for the element.\n\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch); // Do not use regex for chained selectors (for performance).\n\n    textCandidates = filterRegexTokens(textCandidates);\n\n    const checkWithText = textCandidatesToUse => {\n      // Use the deepest possible text selector - works pretty good and saves on compute time.\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter(c => {\n        if (!result) return true;\n        return combineScores(c) < combineScores(result);\n      }); // This is best theoretically possible candidate from the current parent.\n      // We use the fact that widening the scope to grand-parent makes any selector\n      // even less likely to match.\n\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent) return;\n\n      for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens) continue; // Even the best selector won't be too good - skip this parent.\n\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result)) continue; // Update the best candidate that finds \"element\" in the \"parent\".\n\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n        if (!bestPossibleInParent) return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result)) result = combined;\n      }\n    };\n\n    checkWithText(textCandidates); // Allow skipping text on the target element, and using text on one of the parents.\n\n    if (element === targetElement && textCandidates.length) checkWithText([]);\n    return result;\n  };\n\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n\n    if (value === undefined) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n\n    return value;\n  };\n\n  return calculateCached(targetElement, true);\n}\n\nfunction buildCandidates(injectedScript, element) {\n  const candidates = [];\n\n  for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {\n    if (element.hasAttribute(attribute)) candidates.push({\n      engine: 'css',\n      selector: `[${attribute}=${quoteString(element.getAttribute(attribute))}]`,\n      score: 1\n    });\n  }\n\n  if (element.nodeName === 'INPUT') {\n    const input = element;\n    if (input.placeholder) candidates.push({\n      engine: 'css',\n      selector: `[placeholder=${quoteString(input.placeholder)}]`,\n      score: 10\n    });\n  }\n\n  if (element.hasAttribute('aria-label')) candidates.push({\n    engine: 'css',\n    selector: `[aria-label=${quoteString(element.getAttribute('aria-label'))}]`,\n    score: 10\n  });\n  if (element.getAttribute('alt') && ['APPLET', 'AREA', 'IMG', 'INPUT'].includes(element.nodeName)) candidates.push({\n    engine: 'css',\n    selector: `${element.nodeName.toLowerCase()}[alt=${quoteString(element.getAttribute('alt'))}]`,\n    score: 10\n  });\n  if (element.hasAttribute('role')) candidates.push({\n    engine: 'css',\n    selector: `${element.nodeName.toLocaleLowerCase()}[role=${quoteString(element.getAttribute('role'))}]`,\n    score: 50\n  });\n  if (element.getAttribute('name') && ['BUTTON', 'FORM', 'FIELDSET', 'IFRAME', 'INPUT', 'KEYGEN', 'OBJECT', 'OUTPUT', 'SELECT', 'TEXTAREA', 'MAP', 'META', 'PARAM'].includes(element.nodeName)) candidates.push({\n    engine: 'css',\n    selector: `${element.nodeName.toLowerCase()}[name=${quoteString(element.getAttribute('name'))}]`,\n    score: 50\n  });\n\n  if (['INPUT', 'TEXTAREA'].includes(element.nodeName) && element.getAttribute('type') !== 'hidden') {\n    if (element.getAttribute('type')) candidates.push({\n      engine: 'css',\n      selector: `${element.nodeName.toLowerCase()}[type=${quoteString(element.getAttribute('type'))}]`,\n      score: 50\n    });\n  }\n\n  if (['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName)) candidates.push({\n    engine: 'css',\n    selector: element.nodeName.toLowerCase(),\n    score: 50\n  });\n  const idAttr = element.getAttribute('id');\n  if (idAttr && !isGuidLike(idAttr)) candidates.push({\n    engine: 'css',\n    selector: makeSelectorForId(idAttr),\n    score: 100\n  });\n  candidates.push({\n    engine: 'css',\n    selector: element.nodeName.toLocaleLowerCase(),\n    score: 200\n  });\n  return candidates;\n}\n\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n  if (element.nodeName === 'SELECT') return [];\n  const text = (0, _selectorEvaluator.elementText)(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, ' ').substring(0, 80);\n  if (!text) return [];\n  const candidates = [];\n  let escaped = text;\n  if (text.includes('\"') || text.includes('>>') || text[0] === '/') escaped = `/.*${escapeForRegex(text)}.*/`;\n  candidates.push({\n    engine: 'text',\n    selector: escaped,\n    score: 10\n  });\n\n  if (allowHasText && escaped === text) {\n    let prefix = element.nodeName.toLocaleLowerCase();\n    if (element.hasAttribute('role')) prefix += `[role=${quoteString(element.getAttribute('role'))}]`;\n    candidates.push({\n      engine: 'css',\n      selector: `${prefix}:has-text(\"${text}\")`,\n      score: 30\n    });\n  }\n\n  return candidates;\n}\n\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement) return element.parentElement;\n  if (!element.parentNode) return null;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host) return element.parentNode.host;\n  return null;\n}\n\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? '#' + id : `[id=\"${id}\"]`;\n}\n\nfunction cssFallback(injectedScript, targetElement) {\n  const kFallbackScore = 10000000;\n  const root = targetElement.ownerDocument;\n  const tokens = [];\n\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix) path.unshift(prefix);\n    const selector = path.join(' ');\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument);\n    return node === targetElement ? selector : undefined;\n  }\n\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase(); // Element ID is the strongest signal, use it.\n\n    let bestTokenForLevel = '';\n\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector) return {\n        engine: 'css',\n        selector,\n        score: kFallbackScore\n      };\n      bestTokenForLevel = token;\n    }\n\n    const parent = element.parentNode; // Combine class names until unique.\n\n    const classes = [...element.classList];\n\n    for (let i = 0; i < classes.length; ++i) {\n      const token = '.' + classes.slice(0, i + 1).join('.');\n      const selector = uniqueCSSSelector(token);\n      if (selector) return {\n        engine: 'css',\n        selector,\n        score: kFallbackScore\n      }; // Even if not unique, does this subset of classes uniquely identify node as a child?\n\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1) bestTokenForLevel = token;\n      }\n    } // Ordinal is the weakest signal.\n\n\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter(sibling => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? nodeName : `${nodeName}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector) return {\n        engine: 'css',\n        selector,\n        score: kFallbackScore\n      };\n      if (!bestTokenForLevel) bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n\n    tokens.unshift(bestTokenForLevel);\n  }\n\n  return {\n    engine: 'css',\n    selector: uniqueCSSSelector(),\n    score: kFallbackScore\n  };\n}\n\nfunction escapeForRegex(text) {\n  return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction quoteString(text) {\n  return `\"${text.replaceAll(/\"/g, '\\\\\"').replaceAll(/\\n/g, '\\\\n')}\"`;\n}\n\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = '';\n\n  for (const {\n    engine,\n    selector\n  } of tokens) {\n    if (parts.length && (lastEngine !== 'css' || engine !== 'css' || selector.startsWith(':nth-match('))) parts.push('>>');\n    lastEngine = engine;\n    if (engine === 'css') parts.push(selector);else parts.push(`${engine}=${selector}`);\n  }\n\n  return parts.join(' ');\n}\n\nfunction combineScores(tokens) {\n  let score = 0;\n\n  for (let i = 0; i < tokens.length; i++) score += tokens[i].score * (tokens.length - i);\n\n  return score;\n}\n\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n  const joined = selectors.map(tokens => ({\n    tokens,\n    score: combineScores(tokens)\n  }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n\n  for (const {\n    tokens\n  } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    const index = result.indexOf(targetElement);\n\n    if (index === 0) {\n      // We are the first match - found the best selector.\n      return tokens;\n    } // Otherwise, perhaps we can get nth-match?\n\n\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5) continue; // To use nth-match, we must convert everything to css.\n\n    const allCss = tokens.map(token => {\n      if (token.engine !== 'text') return token;\n      if (token.selector.startsWith('/') && token.selector.endsWith('/')) return {\n        engine: 'css',\n        selector: `:text-matches(\"${token.selector.substring(1, token.selector.length - 1)}\")`,\n        score: token.score\n      };\n      return {\n        engine: 'css',\n        selector: `:text(\"${token.selector}\")`,\n        score: token.score\n      };\n    });\n    const combined = joinTokens(allCss);\n    bestWithIndex = [{\n      engine: 'css',\n      selector: `:nth-match(${combined}, ${index + 1})`,\n      score: combineScores(allCss) + 1000\n    }];\n  }\n\n  return bestWithIndex;\n}\n\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === '-' || c === '_') continue;\n    if (c >= 'a' && c <= 'z') characterType = 'lower';else if (c >= 'A' && c <= 'Z') characterType = 'upper';else if (c >= '0' && c <= '9') characterType = 'digit';else characterType = 'other';\n\n    if (characterType === 'lower' && lastCharacterType === 'upper') {\n      lastCharacterType = characterType;\n      continue;\n    }\n\n    if (lastCharacterType && lastCharacterType !== characterType) ++transitionCount;\n    lastCharacterType = characterType;\n  }\n\n  return transitionCount >= id.length / 4;\n}\n\n/***/ })\n\n/******/ })[\"default\"];";
exports.source = source;
//# sourceMappingURL=recorderSource.js.map